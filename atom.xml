<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GALAXY</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangchaofu.cn/"/>
  <updated>2019-01-03T12:45:03.834Z</updated>
  <id>https://yangchaofu.cn/</id>
  
  <author>
    <name>沼泽星空</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二维码生成与解析：jQuery-qrcode</title>
    <link href="https://yangchaofu.cn/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E8%A7%A3%E6%9E%90%EF%BC%9AjQuery-qrcode.html"/>
    <id>https://yangchaofu.cn/二维码生成与解析：jQuery-qrcode.html</id>
    <published>2018-11-17T04:54:16.000Z</published>
    <updated>2019-01-03T12:45:03.834Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前面两篇博文讲述了使用Java在本地生成和解析二维码，其生成的二维码可以用到Web应用中，但是在Web应用中有一种更简单的生成方法就是使用jQuery-qrcode来生成二维码，本片博文就介绍使用这种方法来生成二维码。</p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>本次项目是一个Web项目，可以使用静态的HTML来生成，但是为了更贴近实际使用情况，我使用Java EE项目来演示（使用JSP技术），项目结构很简单，只有一个jsp文件和一个js文件夹，我们将jquery.min.js和jquery.qrcode.min.js两个文件放到项目的WebContent目录的js文件夹之下。  </p><p>所说的两个js文件在网盘以下中给出：  </p><blockquote><p>百度网盘：链接：<a href="https://pan.baidu.com/s/1vQZRPbRKzaQg3-XqsRc-Jw" target="_blank" rel="noopener">https://pan.baidu.com/s/1vQZRPbRKzaQg3-XqsRc-Jw</a><br>提取码：y8cq </p></blockquote><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>使用eclipse-javaee版本创建一个动态web项目，项目目录如图所示：<br><img src="http://t1.aixinxi.net/o_1csg1ce6k1hooe2g1tqs17j21av0a.jpg-j.jpg" alt="项目结构">  </p><p>经过测试之后发现一个问题就是在jQuery-qrcode自带的编码是utf16，无法正常的解析中文，所以需要使用JavaScript函数对其 进行转码，所以在文件中使用了一个utf16to8()的函数对中文进行编码，之后生成的二维码就能正常使用了。</p><p>给出jsp文件中的全部内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;jQuery生成二维码&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/jquery.qrcode.min.js"&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="function">function <span class="title">utf16to8</span><span class="params">(str)</span> </span>&#123; </span><br><span class="line">    var out, i, len, c; </span><br><span class="line">    out = <span class="string">""</span>; </span><br><span class="line">    len = str.length; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) &#123; </span><br><span class="line">    c = str.charCodeAt(i); </span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="number">0x0001</span>) &amp;&amp; (c &lt;= <span class="number">0x007F</span>)) &#123; </span><br><span class="line">        out += str.charAt(i); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; <span class="number">0x07FF</span>) &#123; </span><br><span class="line">        out += String.fromCharCode(<span class="number">0xE0</span> | ((c &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0F</span>)); </span><br><span class="line">        out += String.fromCharCode(<span class="number">0x80</span> | ((c &gt;&gt;  <span class="number">6</span>) &amp; <span class="number">0x3F</span>)); </span><br><span class="line">        out += String.fromCharCode(<span class="number">0x80</span> | ((c &gt;&gt;  <span class="number">0</span>) &amp; <span class="number">0x3F</span>)); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        out += String.fromCharCode(<span class="number">0xC0</span> | ((c &gt;&gt;  <span class="number">6</span>) &amp; <span class="number">0x1F</span>)); </span><br><span class="line">        out += String.fromCharCode(<span class="number">0x80</span> | ((c &gt;&gt;  <span class="number">0</span>) &amp; <span class="number">0x3F</span>)); </span><br><span class="line">    &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> out; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div align=<span class="string">"center"</span>&gt;</span><br><span class="line">生成的二维码如下&lt;br&gt;&lt;br&gt;</span><br><span class="line">&lt;div id="qrcode"&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="comment">//jQuery('#qrcode').qrcode(utf16to8("但是人总得想办法,真的,要么忙着生存,要么赶着去死"));</span></span><br><span class="line">jQuery(<span class="string">'#qrcode'</span>).qrcode(&#123;width: <span class="number">200</span>,height: <span class="number">200</span>,text: utf16to8(<span class="string">"心怀希望是一件好事,也许是最好的事,心怀希望就永远有希望"</span>)&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>生成的二维码如下：<br><img src="http://t1.aixinxi.net/o_1csg1vaq21d5m1c7t1r2721lr8va.jpg-j.jpg" alt=""></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>网页的话一般没有解码的需求，所以老师也没有讲解jQuery解码的说明，所以网页项目只有生成二维码的过程。<br>二维码生成与解析的博文至此告一个段落，由于博主的基础水平所限，所以偏向实用的内容，如何生成和解析二维码是我这次学习的目标，至于二维码的原理等内容，可以去<a href="https://www.imooc.com/video/10309" target="_blank" rel="noopener">慕课网</a>Fcming老师的讲解，本文的所有代码是本人亲手所写并测试的，代码中难免有不足和错误的地方。还有本文偏向Java的技术栈，如果你希望使用PHP生成二维码可以去看看<a href="https://www.imooc.com/learn/862" target="_blank" rel="noopener">PHP QRCode生成二维码</a>这篇课程。<br>最后，再次感谢Fcming老师的讲解和慕课平台。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面两篇博文讲述了使用Java在本地生成和解析二维码，其生成的二维码可以用到Web应用中，但是在Web应用中有一种更简单的生成方法就是使用jQuery-qrcode来生成二维码，本片博文就介绍使用这种方法来生成二维码。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://yangchaofu.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="二维码" scheme="https://yangchaofu.cn/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="JavaScript" scheme="https://yangchaofu.cn/tags/JavaScript/"/>
    
      <category term="Web应用" scheme="https://yangchaofu.cn/tags/Web%E5%BA%94%E7%94%A8/"/>
    
      <category term="JSP页面" scheme="https://yangchaofu.cn/tags/JSP%E9%A1%B5%E9%9D%A2/"/>
    
      <category term="jQRuery" scheme="https://yangchaofu.cn/tags/jQRuery/"/>
    
  </entry>
  
  <entry>
    <title>二维码生成与解析：QRCode</title>
    <link href="https://yangchaofu.cn/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E8%A7%A3%E6%9E%90%EF%BC%9AQRCode.html"/>
    <id>https://yangchaofu.cn/二维码生成与解析：QRCode.html</id>
    <published>2018-11-17T02:54:16.000Z</published>
    <updated>2019-01-03T14:05:37.829Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍使用QRCode生成和解析二维码</p><a id="more"></a><h3 id="资源准备"><a href="#资源准备" class="headerlink" title="资源准备"></a>资源准备</h3><p>本次使用的是QRCode的Java构件生成和解析二维码，所以需要用到QRCode的JAR文件，在网盘以下中给出：</p><blockquote><p>百度网盘：链接：<a href="https://pan.baidu.com/s/1vQZRPbRKzaQg3-XqsRc-Jw" target="_blank" rel="noopener">https://pan.baidu.com/s/1vQZRPbRKzaQg3-XqsRc-Jw</a><br>提取码：y8cq </p></blockquote><h3 id="QRCode创建二维码"><a href="#QRCode创建二维码" class="headerlink" title="QRCode创建二维码"></a>QRCode创建二维码</h3><p>使用QRCode生成二维码是使用的Java的绘图工具。代码的步骤和详细说明在代码注释中已经给出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics2D;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.swetake.util.Qrcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateQRCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> version = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> picWidth = <span class="number">67</span> + <span class="number">12</span> * (version - <span class="number">1</span>);  <span class="comment">//生成二维码的宽度根据次公式确定</span></span><br><span class="line"><span class="keyword">int</span> picHeight =<span class="number">67</span> + <span class="number">12</span> * (version - <span class="number">1</span>);  <span class="comment">//生成二维码的高度根据次公式确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.定义一个Qrcode 对象并设置其纠错等级,编码模式(N-数字,A-英文字符,B-其他字符),版本1-40</span></span><br><span class="line">Qrcode x = <span class="keyword">new</span> Qrcode();</span><br><span class="line">x.setQrcodeErrorCorrect(<span class="string">'M'</span>);</span><br><span class="line">x.setQrcodeEncodeMode(<span class="string">'B'</span>);</span><br><span class="line">x.setQrcodeVersion(version);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.定义二维码内容</span></span><br><span class="line">String qrData = <span class="string">"https://yangchaofu.cn"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.定义一个缓冲区图片</span></span><br><span class="line">BufferedImage bufferedImage = <span class="keyword">new</span> BufferedImage(picWidth,picHeight,BufferedImage.TYPE_INT_RGB);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.定义一个图形对象(Graphic2D),并将缓冲区图片赋值给图形对象,并进行背景前景的设置和图像背景色的填涂(clearRect)</span></span><br><span class="line">Graphics2D gs = bufferedImage.createGraphics();</span><br><span class="line">gs.setBackground(Color.WHITE);</span><br><span class="line">gs.setColor(Color.BLACK);</span><br><span class="line">gs.clearRect(<span class="number">0</span>, <span class="number">0</span>, picWidth, picHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.将需要写入二维码的内容转为字节并设置编码为UTF-8</span></span><br><span class="line"><span class="keyword">byte</span>[] d = qrData.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.进行二维码的绘制,使用一个偏移量pixoff</span></span><br><span class="line"><span class="keyword">int</span> pixoff = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(d.length &gt; <span class="number">0</span> &amp;&amp; d.length &lt; <span class="number">120</span>)&#123;</span><br><span class="line"><span class="keyword">boolean</span>[][] s = x.calQrcode(d);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i][j])&#123;</span><br><span class="line">gs.fillRect(j*<span class="number">3</span> + pixoff, i*<span class="number">3</span> + pixoff, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.gs释放屏幕资源,缓冲区图片刷新</span></span><br><span class="line">gs.dispose();</span><br><span class="line">bufferedImage.flush();</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.将生成的图片输出</span></span><br><span class="line">ImageIO.write(bufferedImage, <span class="string">"png"</span>, <span class="keyword">new</span> File(<span class="string">"C:/Users/yangc/Desktop/qr.png"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建结果：<br><img src="http://imglf6.nosdn0.126.net/img/MVlXRlBpYVg1NW1jZmIxN3cySGh4YkhXK2ZUUUVwS3FUWnJtRUpySkxGOGk5ancyQWRrdVF3PT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" alt="点击前往查看"></p><h3 id="QRCode解析二维码"><a href="#QRCode解析二维码" class="headerlink" title="QRCode解析二维码"></a>QRCode解析二维码</h3><p>QRCode解析二维码的效果并不如zxing，所以如果项目中使用，建议使用zxing。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jp.sourceforge.qrcode.QRCodeDecoder;</span><br><span class="line"><span class="keyword">import</span> jp.sourceforge.qrcode.data.QRCodeImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用QRCode进行二维码解析</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeQRCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.指定要解析的文件</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"C:/Users/yangc/Desktop/pic.png"</span>);</span><br><span class="line"><span class="comment">//2.将文件使用ImageIO读取到BufferedImage中</span></span><br><span class="line">BufferedImage bufferedImage = ImageIO.read(file);</span><br><span class="line"><span class="comment">//3.定义一个QRCodeDecode 对象</span></span><br><span class="line">QRCodeDecoder codeDecode = <span class="keyword">new</span> QRCodeDecoder();</span><br><span class="line"><span class="comment">////4.使用一个byte[]接受解析出来的内容</span></span><br><span class="line"><span class="keyword">byte</span>[] contentsByte = codeDecode.decode(<span class="keyword">new</span> MyQRCodeImage(bufferedImage));</span><br><span class="line"><span class="comment">////5.对解析的内容进行String化并设置编码格式</span></span><br><span class="line">String contentsStr = <span class="keyword">new</span> String(contentsByte,<span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(contentsStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-5步合在一起</span></span><br><span class="line"><span class="comment">//String result  = new String(codeDecode.decode(new MyQRCodeImage(bufferedImage)),"UTF-8");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//System.out.println(result);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个MyQRCodeImage类实现QRCode接口,用于二维码解析</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQRCodeImage</span> <span class="keyword">implements</span> <span class="title">QRCodeImage</span></span>&#123;</span><br><span class="line"></span><br><span class="line">BufferedImage bufferedImage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyQRCodeImage</span><span class="params">(BufferedImage bufferedImage)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.bufferedImage = bufferedImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bufferedImage.getHeight();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPixel</span><span class="params">(<span class="keyword">int</span> arg0, <span class="keyword">int</span> arg1)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bufferedImage.getRGB(arg0, arg1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bufferedImage.getWidth();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析结果：<br><a href="https://yangchaofu.cn">https://yangchaofu.cn</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>使用QRCode进行二维码的创建和解析说实话体验并不很好，有时候解析出来的一串内容，并没能将编码内容实际解析出来，所以建议使用<a href="https://yangchaofu.cn/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-zxing.html">zxing</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍使用QRCode生成和解析二维码&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://yangchaofu.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://yangchaofu.cn/tags/Java/"/>
    
      <category term="二维码" scheme="https://yangchaofu.cn/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="QRCode" scheme="https://yangchaofu.cn/tags/QRCode/"/>
    
  </entry>
  
  <entry>
    <title>二维码生成与解析：zxing</title>
    <link href="https://yangchaofu.cn/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E8%A7%A3%E6%9E%90%EF%BC%9Azxing.html"/>
    <id>https://yangchaofu.cn/二维码生成与解析：zxing.html</id>
    <published>2018-11-16T14:40:58.000Z</published>
    <updated>2019-01-03T14:04:29.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍使用开源库<a href="https://github.com/zxing/zxing" target="_blank" rel="noopener">zxing</a>生成和解析二维码。  </p><a id="more"></a><p>使用zxing首先需要使用源码中的core和javase两个文件制作JAR文件，为了不偏离主题，将这部分放在最后一节讲解，本文直接提供制作好的JAR文件。  </p><blockquote><p>百度网盘：链接：<a href="https://pan.baidu.com/s/1vQZRPbRKzaQg3-XqsRc-Jw" target="_blank" rel="noopener">https://pan.baidu.com/s/1vQZRPbRKzaQg3-XqsRc-Jw</a><br>提取码：y8cq </p></blockquote><h3 id="使用zxing创建二维码"><a href="#使用zxing创建二维码" class="headerlink" title="使用zxing创建二维码"></a>使用zxing创建二维码</h3><p>将网盘中zxing文件夹中的zxing3.x.jar文件导入到项目中。<br>以下的代码将在 C://Users/yangc/Desktop文件夹中创建一张二维码（pic.png）,二维码所携带的内容为：<a href="https://yangchaofu.cn。创建过程总共分为两个大步骤，第一个大步骤是创建前的准备工作，包含两个小步骤；第二个大步骤是创建步骤" target="_blank" rel="noopener">https://yangchaofu.cn。创建过程总共分为两个大步骤，第一个大步骤是创建前的准备工作，包含两个小步骤；第二个大步骤是创建步骤</a> ，包含三个小步骤，整体可以用以下列表结构表示：  </p><ul><li>制作前准备工作<ul><li>定义图片信息和二维码内容</li><li>定义二维码的属性信息，包括纠错等级，编码格式，二维码边距</li></ul></li><li>制作过程<ul><li>使用MultiFormatRead的encode方法生成一个BitMatrix对象</li><li>指定输出路径</li><li>使用MatrixToImageWriter的writeToPath方法将BitMatrix对象写入文件</li></ul></li></ul><p>以下代码是对上述描述的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.BarcodeFormat;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.EncodeHintType;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.MultiFormatWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.client.j2se.MatrixToImageWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.BitMatrix;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java进行二维码制作-zxing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangchaofu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8.192</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateQRCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//制作二维码的准备工作</span></span><br><span class="line"><span class="comment">//1.定义所要生成的二维码图片的长,宽,图片格式和所携带的信息</span></span><br><span class="line"><span class="keyword">int</span> picWidth = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> picHeight = <span class="number">300</span>;</span><br><span class="line">String picFormat = <span class="string">"png"</span>;</span><br><span class="line">String picContents = <span class="string">"https://yangchaofu.cn"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.定义二维码的基本属性配置,使用散列表存储,最基本的设置包括二维码的编码格式,纠错等级和图片的边距</span></span><br><span class="line">HashMap hints = <span class="keyword">new</span> HashMap();</span><br><span class="line">hints.put(EncodeHintType.CHARACTER_SET, <span class="string">"utf-8"</span>);<span class="comment">//设置编码格式,utf-8可设置中文</span></span><br><span class="line">hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);   <span class="comment">//设置纠错等级</span></span><br><span class="line">hints.put(EncodeHintType.MARGIN, <span class="number">1</span>);   <span class="comment">//设置生成二维码边距</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成二维码的步骤</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.定义一个为BitMatrix 对象,使用MultiFormatWriter 对象的encode方法设置二维码的内容,编码格式BarcodeFormat,宽,高,设置信息hints</span></span><br><span class="line">BitMatrix bitMatrix = <span class="keyword">new</span> MultiFormatWriter().encode(picContents, BarcodeFormat.QR_CODE, picWidth, picHeight,hints);</span><br><span class="line"><span class="comment">//2.定义一个Path对象用于确定文件的输出位置</span></span><br><span class="line">Path file = <span class="keyword">new</span> File(<span class="string">"C:/Users/yangc/Desktop/pic.png"</span>).toPath();</span><br><span class="line"><span class="comment">//3.使用MatrixToImageWriter 对象的writeToPath方法,将二维码图片输出到指定的位置,设置格式为我们准备阶段的格式</span></span><br><span class="line">MatrixToImageWriter.writeToPath(bitMatrix, picFormat, file);</span><br><span class="line">System.out.println(<span class="string">"生成二维码成功!"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行结果：  </p><p><img src="http://imglf6.nosdn0.126.net/img/MVlXRlBpYVg1NWtaM29KamxXUFROd2dEdC9jQWxmOVJock5ST29IQ3pXWTRaZFhjb3d1bk9nPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" alt="点击前往查看">  </p><h3 id="使用zxing解析二维码"><a href="#使用zxing解析二维码" class="headerlink" title="使用zxing解析二维码"></a>使用zxing解析二维码</h3><p>解析二维码包括三个大步骤，用以下结构描述</p><ul><li>解析前准备<ul><li>准备一个文件对象，指向需要解析的二维码图片</li><li>使用ImageIO读取该图片对象为缓冲区图片BufferedImage</li><li>将BufferedImage转换为一个二进制位图对象</li><li>定义一个散列表存取二维码的编码格式</li></ul></li><li>解析过程步骤<ul><li>定义一个MultiFormatReader 对象,用于解码</li><li>定义一个Result 对象用来获取解析的结果,这里的参数使用到前面准备的两个重要的数据,被转换为BinaryBitmap的图片对象,和定义解码配置的散列表hints</li></ul></li></ul><ul><li>解析结果的展示（可以直接toString得到解析结果，也可是使用getText获取解析文本，使用getBarcodeFromat获取二维码格式）</li></ul><p>以下是上述过程的代码表述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.BinaryBitmap;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.EncodeHintType;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.MultiFormatReader;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.Result;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.client.j2se.BufferedImageLuminanceSource;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.HybridBinarizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeQRCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//解析前准备步骤</span></span><br><span class="line"><span class="comment">//1.定义一个File 对象,指向我们要解码的二维码位置</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"C:/Users/yangc/Desktop/qr.png"</span>);</span><br><span class="line"><span class="comment">//2.定义一个BufferedImage 对象,并使用ImageIO类的read方法读取我们的File对象(一张图片)</span></span><br><span class="line">BufferedImage image = ImageIO.read(file);</span><br><span class="line"><span class="comment">//3.定义一个BinaryBitmap 对象,使用多重嵌套 实例化将我们的image转换成一个BinaryBitmap对象,多重嵌套声明包括HybridBinarizer-&gt;(参数)BufferedImageLuminanceSource-&gt;(参数)BufferedImage[image]</span></span><br><span class="line">BinaryBitmap binaryBitmap = <span class="keyword">new</span> BinaryBitmap(<span class="keyword">new</span> HybridBinarizer(<span class="keyword">new</span> BufferedImageLuminanceSource(image)));</span><br><span class="line"><span class="comment">//4.定义一个散列表,指定编码的一对键值</span></span><br><span class="line">HashMap hints = <span class="keyword">new</span> HashMap();</span><br><span class="line">hints.put(EncodeHintType.CHARACTER_SET, <span class="string">"utf-8"</span>); <span class="comment">// 设置编码格式,utf-8可设置中文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析过程步骤</span></span><br><span class="line"><span class="comment">//1.定义一个MultiFormatReader 对象,用于解码</span></span><br><span class="line">MultiFormatReader formatRead = <span class="keyword">new</span> MultiFormatReader();</span><br><span class="line"><span class="comment">//2.定义一个Result 对象用来获取解析的结果,这里的参数使用到前面准备的两个重要的数据,被转换为BinaryBitmap的图片对象,和定义解码配置的散列表hints</span></span><br><span class="line">Result result = formatRead.decode(binaryBitmap, hints);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析结果展示</span></span><br><span class="line"><span class="comment">//rusult的toString可以展示解析结果</span></span><br><span class="line">System.out.println(<span class="string">"解析结果:"</span>+result.toString());</span><br><span class="line"><span class="comment">//result文本信息可以展示二维码所携带的文本内容</span></span><br><span class="line">System.out.println(<span class="string">"二维码文本内容:"</span>+result.getText());</span><br><span class="line"><span class="comment">//解码的格式可以获取二维码的编码标准和格式</span></span><br><span class="line">System.out.println(<span class="string">"二维码格式:"</span>+result.getBarcodeFormat());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的解析结果：<br>解析结果：<a href="https://yangchaofu.cn">https://yangchaofu.cn</a><br>二维码文本内容：<a href="https://yangchaofu.cn">https://yangchaofu.cn</a><br>二维码格式：QR_CODE  </p><h3 id="使用zxing源码制作JAR"><a href="#使用zxing源码制作JAR" class="headerlink" title="使用zxing源码制作JAR"></a>使用zxing源码制作JAR</h3><p>github上有很多非常优秀的开源项目，这次使用的zxing就是其中之一，如何复用这些代码呢，对于Java来说，jar文件是不陌生的。我在这次实践中第一次体会到了使用源码制作jar文件的过程，记录在此处。  </p><ol><li>新建一个Jave项目；</li><li>将下载的zxing文件夹中的core和javase两个文件中下的com文件复制到项目的src中，复制中会有文件存在的提示，选择<strong>是</strong>就可以；</li><li>由于项目不是完整的项目，项目中会有很多的错误提示，这个不用管，因为我们使用IDE的时候，IDE会帮助我们管理文件的，所以直接选择导出JAR文件，之后我们就可以得到一个最新的zxing的可复用构件。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上代码实现了使用zxing创建和解析二维码，经测试所生成的二维码识别率和准确性都是满足要求的，解析代码的识别率也很高。zxing是一个很好的解决方案。<br>感谢<a href="https://www.imooc.com/video/10316/0" target="_blank" rel="noopener">慕课网</a>Fcming老师的讲解和慕课网这个平台，十分感谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍使用开源库&lt;a href=&quot;https://github.com/zxing/zxing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zxing&lt;/a&gt;生成和解析二维码。  &lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://yangchaofu.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://yangchaofu.cn/tags/Java/"/>
    
      <category term="二维码 - zxing" scheme="https://yangchaofu.cn/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81-zxing/"/>
    
  </entry>
  
  <entry>
    <title>操作系统：时间片轮转调度算法</title>
    <link href="https://yangchaofu.cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.html"/>
    <id>https://yangchaofu.cn/操作系统：时间片轮转调度算法.html</id>
    <published>2018-07-11T10:23:09.000Z</published>
    <updated>2019-01-03T12:45:23.234Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间片轮转法是操作系统进程调度的一种算法，该算法的目的旨在实现多道程序技术，即宏观上程序并发。</p><a id="more"></a>  <h3 id="串行、并行和并发"><a href="#串行、并行和并发" class="headerlink" title="串行、并行和并发"></a>串行、并行和并发</h3><p>首先理解这个算法要理解什么是并发、并行和串行。用一个别人通俗易懂的解释：  </p><ul><li>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行，你是串行执行的。</li><li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</li><li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。<br><em>并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有<strong>同时</strong>处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』。</em> <a href="https://www.zhihu.com/question/33515481/answer/58849148" target="_blank" rel="noopener">该解释来源</a>  </li></ul><h3 id="时间片轮转简介"><a href="#时间片轮转简介" class="headerlink" title="时间片轮转简介"></a>时间片轮转简介</h3><p>时间片轮转法是一种操作系统赋予CPU软件实现的并发能力。单核CPU能在宏观上做到并发，实际在微观上是串行的。该算法的关键在于时间片的划分，时间片过短导致操作系统进行频繁的进程调度，浪费资源；时间片过长会变成串行，算法也就是失去了价值，我使用Java语言模拟该算法地实现。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li>进程的数据结构：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class Process&#123;</span><br><span class="line">    <span class="keyword">public</span> String processName;  <span class="comment">//进程名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arriveTime;  <span class="comment">//进程到达时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> startTime;   <span class="comment">//进程开始时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> endTime;   <span class="comment">//进程结束时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> durationTime;    <span class="comment">//进程持续时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> processStatus;    <span class="comment">//进程状态(taking  wait  run  finished)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> runTimed;    <span class="comment">//进程已经运行的时间</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> processName[<span class="number">20</span>];<span class="comment">//进程名称</span></span><br><span class="line">    <span class="keyword">int</span> arriveTime;<span class="comment">//进程到达时间</span></span><br><span class="line">    <span class="keyword">int</span> startTime;<span class="comment">//进程开始时间</span></span><br><span class="line">    <span class="keyword">int</span> endTime;<span class="comment">//进程结束时间</span></span><br><span class="line">    <span class="keyword">int</span> runTime;<span class="comment">//进程运行时间大小</span></span><br><span class="line">    <span class="keyword">int</span> turnOverTime;<span class="comment">//周转时间</span></span><br><span class="line">    <span class="keyword">int</span> userweightTurnOverTime;<span class="comment">//带权周转时间</span></span><br><span class="line">    <span class="keyword">char</span> provessStatus[<span class="number">10</span>];<span class="comment">//进程状态</span></span><br><span class="line">    <span class="keyword">int</span> runTimeed; <span class="comment">//进程已经运行的时间</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间片轮转法是操作系统进程调度的一种算法，该算法的目的旨在实现多道程序技术，即宏观上程序并发。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://yangchaofu.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="https://yangchaofu.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="C语言" scheme="https://yangchaofu.cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Git学习总结</title>
    <link href="https://yangchaofu.cn/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html"/>
    <id>https://yangchaofu.cn/Git学习总结.html</id>
    <published>2018-06-26T01:42:33.000Z</published>
    <updated>2019-01-03T12:46:40.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本来以为一天完成的Git学习任务，用了三天勉强完成，真是拖延病入膏肓，不过还好没有拖到猴年马月，也算完成了一个小任务，那就上来好好的总结一番。</p><a id="more"></a><p>Git是什么我想有好多人听过但是不清楚，不过可能是我比较Low，直到现在才基本算入门吧，但是我相信还有好多不知道的，比如不是计算机专业的，好了废话不多说，我们一个问题一个问题来说一下！！</p><h3 id="什么是Git？"><a href="#什么是Git？" class="headerlink" title="什么是Git？"></a>什么是Git？</h3><p>先引用出<a href="https://git-scm.com/" target="_blank" rel="noopener">官方</a>的说法：</p><blockquote><p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p></blockquote><blockquote><p>Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows.</p></blockquote><p>翻译一下就是：</p><blockquote><p>Git是一个免费开源的分布式版本控制系统，其设计的目的是快速、高效的处理从小到大的各种项目。</p></blockquote><blockquote><p>Git很容易学习，占用空间小，执行快如闪电。它比其它版本控制台工具，比如：SbuVersion，CVS，Perforce和ClearCase具有更优的特性，比如简易的本地分支，便利的暂存区域和多工作流。</p></blockquote><p>大概意思还是表达出来了，就是它是什么，它和同类产品相比，特性是什么。首先它是一个版本控制工具，这个概念学过软件工程的同学都听过，不过没实践过还是很难理解，我会以写大作业的例子作类比。特性就是快，小，强，怎么强还给出了具体的说明，分支，暂存和多工作流等，侧面的表达了其它同样类型工具的各种不足，比如占用空间大，速度慢，分支复杂切换分支慢，暂存不方便等等。</p><p>顺便说一句，我最初了解Git的时候是因为GitHub，编程的人应该都知道GitHub，上面有很多的开源软件项目，毕竟我们是面向API编程，那它和Git之间有什么关系呢？后面会简单说一下，除了国外的GitHub其实还有国内的Gitee（码云），这名字起的好。</p><h3 id="什么是版本控制？"><a href="#什么是版本控制？" class="headerlink" title="什么是版本控制？"></a>什么是版本控制？</h3><p>我以word为例举个例子，比如你在写毕业设计，你首先先建了一个word文档，叫作<code>XXX毕业设计</code>，然后我们在里面一顿写，终于完成了初稿。</p><p><img src="http://t1.aixinxi.net/o_1cgsvrmvn10m910ji1uv1jt91b36a.jpg-w.jpg" alt="XXX毕业设计初稿"></p><p>然后交给我们的导师去检查，但是导师看了十分不满意，这写的什么玩意，就这还想毕业……然后你需要对你的的毕业设计进行修改，你又怕改了之后以前的内容找不回来了，所以你将你的毕业设计备份了一份，把原来的版本叫做<code>XXX毕业设计-初稿</code>，新版本叫<code>XXX毕业设计-0.01</code></p><p><img src="http://t1.aixinxi.net/o_1cgt01fqu1megfb91jujhtl1715a.jpg-w.jpg" alt="XXX毕业设计-0.01版"></p><p>然后你在0.01版里面一顿乱改，之后再交到导师哪里？导师还是不满意，还不如第一版。。<br>你又在0.01版新建一个备份叫0.02，又在里面一顿胡乱增删改，你的文件夹变成了这样：</p><p><img src="http://t1.aixinxi.net/o_1cgt0c4aec1u4nfedk10msjn2a.jpg-w.jpg" alt="XXX毕业设计-0.02"></p><p>然后你一直进行这样的操作，突然你的导师和你说，我觉得你有一次给我看的有一个地方我觉的挺好的，你把它重新写上，你们说的你都记得，但是你就是不知道在那个版本了，这样又是一顿找，总之各种工作效率低。</p><p>以这样一个简单的例子类比了版本控制这个过程，但是实际的工程项目比这要复杂的多，一个版本和另一个版本之间的修改可能达到上百处，工程文件的复杂程度是不可想象的，此时版本控制就变得很必要。</p><h3 id="那Git怎么学？"><a href="#那Git怎么学？" class="headerlink" title="那Git怎么学？"></a>那Git怎么学？</h3><p>这里就需要祭出我的Git恩师廖雪峰老师了，他的Git教程我觉得最有条理，入门首选：</p><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰老师的Git教程</a></p></blockquote><p>其次就是官方的教程了，多去逛逛必定好处多多：</p><blockquote><p><a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5" target="_blank" rel="noopener">Git官方中文文档</a></p></blockquote><h3 id="学了用在什么地方？"><a href="#学了用在什么地方？" class="headerlink" title="学了用在什么地方？"></a>学了用在什么地方？</h3><ol><li><p>首先Git的起源就是用于软件的版本控制，所以第一用途就是软件版本控制；</p></li><li><p>对于非开发人员来说，Git可以用于Office文档的版本控制，我亲测，Git是可以控制Office2016所产生的文档的，有一个需要注意的点是Git在分支切换的时候要关闭Office软件以解除文档的占用。</p></li></ol><h3 id="GitHub和Git什么关系？"><a href="#GitHub和Git什么关系？" class="headerlink" title="GitHub和Git什么关系？"></a>GitHub和Git什么关系？</h3><p>如果已经认真学习了廖雪峰老师的教程，那我想这个问题已经明了，我这里只是用自己的话说一遍，Git最大的特点就是是它是分布式的版本控制系统，所以它的工作都是在本地的，如果有多人一起工作，那么使用GitHub这样的Git服务器只是充当一个交换的作用，每个合法的用户都可以向GitHub中push自己的修改，它其实还提供了一个源代码分享平台，可以这样说Git和GitHub极大的促进了代码的流通，它使全球的开发者连结在了一起。而现在微软收购了GitHub，这家全球软件巨头在开源的动作有目共睹，我相信它能很好的经营GitHub。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Git能做很多事情，电子数据最大的优势就是其快速的更迭，这是很有利的，数据的易于产生和交换使的我们的生活在数字的影响下磅礴发展，互联网将人们与世界相连，这是人类文明的创举。而正如大家所知，万维网的发明人Timothy John Berners-Lee，并没有从他的贡献中获取利益，Linus Towards不仅发明了Linux而且发明了Git，这些人都是值得我们去尊敬和铭记的，代码是现代的魔法，能接触这个行业是我的幸运，希望自己能立足当下，以成为像他们一样的代码大师而努力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来以为一天完成的Git学习任务，用了三天勉强完成，真是拖延病入膏肓，不过还好没有拖到猴年马月，也算完成了一个小任务，那就上来好好的总结一番。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://yangchaofu.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Git" scheme="https://yangchaofu.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构：快速排序法</title>
    <link href="https://yangchaofu.cn/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B3%95.html"/>
    <id>https://yangchaofu.cn/算法与数据结构：快速排序法.html</id>
    <published>2018-06-20T14:53:25.000Z</published>
    <updated>2019-01-03T12:50:43.452Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>快速排序法是排序算法中综合性能最好的一种，Java语言和C++语言都自带了快速排序算法的库函数，足以见得其效率。</p><a id="more"></a><p>本次算法的实现思路来自于<a href="http://blog.51cto。com/ahalei/1365285" target="_blank" rel="noopener">博客</a>，网上的快速排序实现方式基本有两种形式，其中之一就是本文参考的这一种，还有一种是百度百科里面的哪一种，具体那种更优我觉得差异不大，其核心思路都是一样的。</p><p>本文使用的快速排序算法的思路：<br>从待排序数组中找一个数作为标杆(对于这个数怎么选择众说纷纭,我为了让算法简单选得是每次待排序数组的第一个元素)，每一趟快速排序将比标杆大的数放在它的右边，比它小的数放在标杆的左边，实现一轮快速排序。<br>然后通过递归调用，将标杆左边的数组又作为一个参数,直到需要排序的数组只有一个数为止。</p><p>实例：有待排序数组array，其长度为arr_len，其中的数据元素有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13,22,58,3,1,2，1</span><br></pre></td></tr></table></figure><p>共计有七个个元素，我们以第一个元素13为标杆，进行第一轮快速排序，得到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 3 13 58 22</span><br></pre></td></tr></table></figure><p>可以看到，我们将比13大的元素放在了该元素的右边，比13小的元素放在了该元素的左边，但是数组还不是有序的。但程序已经基本有序，我们以13为分割，对13左边和右边的数组再次实现上述过程。</p><p>13左边已经有序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1，1，2，3</span><br></pre></td></tr></table></figure></p><p>13右边：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">待排序数组：58，22</span><br><span class="line">排序完成：22，58</span><br></pre></td></tr></table></figure></p><p>由于我们传递的是数组的地址（指针方式）和需要排序的数组的下标，比如13右边的数组传递的就是数组<code>array，start：6，finish：7</code></p><p>程序的大概思路如上所述，下面给出代码实现，本次采用C语言实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    本程序实现对一组整形数的快速排序实现</span></span><br><span class="line"><span class="comment">    2018年6月20日 16:38:43</span></span><br><span class="line"><span class="comment">    yangchaofu</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*两种数组传递的函数原型*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="comment">// void quicksort(int *array,int array_length);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">13</span>,<span class="number">22</span>,<span class="number">58</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arr_len = <span class="keyword">sizeof</span> <span class="built_in">array</span> / <span class="keyword">sizeof</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/*输出数组*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Array's length: %d\n"</span>,arr_len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    quicksort(<span class="built_in">array</span>,<span class="number">0</span>,arr_len<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">/*排序后的输出结果*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">quicksort函数对给定的数组进行快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*递归结束条件,很重要的一个点*/</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l = left, r = right;</span><br><span class="line">    <span class="comment">/*每次排序一需要排序的数组的第一个数作为标杆,将比它大的数放在它的右边,比它小的数放在它的左边(倒序与之相反)*/</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="built_in">array</span>[left];</span><br><span class="line">    <span class="keyword">while</span>(l != r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*从右往左找一个比标杆temp小的数,l &lt; r 避免出现l比r大程序还在循环的异常,程序在l==r时需要跳出循环*/</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[r] &gt;= temp &amp;&amp; l &lt; r)</span><br><span class="line">            r--;</span><br><span class="line">        <span class="comment">/*从左往右找一个比标杆temp大的数*/</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[l] &lt;= temp &amp;&amp; l &lt; r)</span><br><span class="line">            l++;</span><br><span class="line">        <span class="comment">/*寻找完毕,执行至此,找个一个比标杆小的值array[r]和一个比标杆大的值array[l]*/</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*如果目前找到的比标杆小的值array[r]在比标杆大的值array[l]的右边,即:两数下标 l &lt; r ,则交换两个数*/</span></span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            t = <span class="built_in">array</span>[l];</span><br><span class="line">            <span class="built_in">array</span>[l] = <span class="built_in">array</span>[r];</span><br><span class="line">            <span class="built_in">array</span>[r] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*上面的循环实现快速排序中的比标杆大的数和比标杆小的数的交换,快速排序的交换逻辑可以有多种实现方式</span></span><br><span class="line"><span class="comment">      除以上实现方式外,还有标杆在比较中,随着程序的执行进行位置的更换.</span></span><br><span class="line"><span class="comment">      本程序实现其中一种逻辑,到目前为止,标杆依旧在数组的最左边,需要将其和l=r这个位置的数进行交换.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">int</span> temporary =  <span class="built_in">array</span>[r];</span><br><span class="line">   <span class="built_in">array</span>[r] = temp;</span><br><span class="line">   <span class="built_in">array</span>[left] = temporary;</span><br><span class="line">    <span class="comment">/*至此,一趟快速排序结束,使用递归重复上述过程</span></span><br><span class="line"><span class="comment">      此处递归的写法有两种,使用的r下标实际上与l下标的值是相等的,使用那一个都可以.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    quicksort(<span class="built_in">array</span>,left,r<span class="number">-1</span>);</span><br><span class="line">    quicksort(<span class="built_in">array</span>,r+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快速排序法是排序算法中综合性能最好的一种，Java语言和C++语言都自带了快速排序算法的库函数，足以见得其效率。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://yangchaofu.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C语言" scheme="https://yangchaofu.cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="排序算法" scheme="https://yangchaofu.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>允许自己虚度时光</title>
    <link href="https://yangchaofu.cn/%E5%85%81%E8%AE%B8%E8%87%AA%E5%B7%B1%E8%99%9A%E5%BA%A6%E6%97%B6%E5%85%89.html"/>
    <id>https://yangchaofu.cn/允许自己虚度时光.html</id>
    <published>2018-05-18T14:37:08.000Z</published>
    <updated>2019-01-03T12:52:24.171Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我慢慢明白了自己为什么不快乐，因为我总是期待一个结果。看一本书期待它让我变得深刻，吃饭游泳期待它让我一斤斤瘦下来，发一条短信期待它被回复，写一个故事说一个心情期待它被关注被安慰，参加一个活动期待换来充实丰富的经历。这些预设的期待如果实现了，长舒一口气。如果没有实现呢？自怨自艾。可是小时候也是同一个我，用一个下午的时间看蚂蚁搬家，等石头开花，小时候不期待结果，小时候哭笑都不打折。             —<em>《允许自己虚度时光》</em></p><a id="more"></a><p>这久的主要任务是软考，下周就是软考的时间了，这次的准备比前一次要好很多，复习了好多的内容，但是心中还是没有底，没有稳过的把握。对于拖延的我来说，这段时间也算是有了极大的改变了，问题在于将习惯坚持下去。</p><p>回想以前的生活，可能是生活过的太过安逸了。现在总算明白了啥叫“生于忧患，死于安乐”。我以前就暗暗下过决心，要把软考和四级当作我的大学毕业考，我现在就在路上，所以感到无比的充实，把心中的想法吐出来是很舒畅的一件事情。</p><p>软考的内容很广，即使考过软考也并不能说明我就具有什么能力了，只是一个重新的开始，后面的路还很长，对于计算机的学生来说软考的难度不大，但是必须什么都知道一点，不然是可能通过的，初级的考试我不太了解，但是我觉得综合下来，中级是比较适合我的，而且考点也都是学习的内容，刚好可以和课堂互补，还有一周的时间，这周最主要的任务是突破大题，避免重蹈覆辙，不走前次的老路。说起来，前次的成绩给了我不错的激励，我知道自己不会过，但是能看到希望，但是这点滴的差距，往往是瓶颈，所以，认真准备才能通过。</p><p>四级的话这次也是有很大的投资，希望能看到回报，但是时间同样紧迫，感觉在词汇方面还有很大的不足，往往一个单词就能让一篇阅读难度成倍的增加，所以词汇不能懈怠，软考之后就全面转入四级的复习，不要让课程的东西影响了自己的，说句实话，大学真的是要自己找出路的，老师根本不管你的死活，他们有时甚至连自己的学习任务都完不成，所以，四级和软考，必须通过，加油。</p><hr><p>越努力，就越不迷茫，当不知道要干什么的时候，可以看看自己给自己列的书单，随便找一本，竭尽全力的全看，能看懂多少，看多少，成功最重要的一点，我觉得是控制自己的欲望。</p><p>写下这些话，给自己以激励，希望自己能努力前行，不忘初心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我慢慢明白了自己为什么不快乐，因为我总是期待一个结果。看一本书期待它让我变得深刻，吃饭游泳期待它让我一斤斤瘦下来，发一条短信期待它被回复，写一个故事说一个心情期待它被关注被安慰，参加一个活动期待换来充实丰富的经历。这些预设的期待如果实现了，长舒一口气。如果没有实现呢？自怨自艾。可是小时候也是同一个我，用一个下午的时间看蚂蚁搬家，等石头开花，小时候不期待结果，小时候哭笑都不打折。             —&lt;em&gt;《允许自己虚度时光》&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://yangchaofu.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="软考" scheme="https://yangchaofu.cn/tags/%E8%BD%AF%E8%80%83/"/>
    
      <category term="四级" scheme="https://yangchaofu.cn/tags/%E5%9B%9B%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>从零开始搭建博客|Hexo+Github+NexT</title>
    <link href="https://yangchaofu.cn/Hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2.html"/>
    <id>https://yangchaofu.cn/Hexo从零开始搭建博客.html</id>
    <published>2018-05-10T09:24:13.000Z</published>
    <updated>2019-01-03T13:02:18.013Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>个人博客是继Email、BBS、IM之后的第四种网络信息传播方式，是一个区别于当前流行的（QQ空间，微信朋友圈，微信公众号，微博，贴吧，知乎，简书，论坛）信息分享平台，他有强烈的个人标识和非常高的个性化。说了这么多，我想说的是我搭建了一个博客，我有话要说，:muscle:</p><a id="more"></a><p>博客诞生同其他几个一样，在互联网兴起之后，人们对信息分享和流通的需求逐渐加大，而这个需求在当时还不能由上述所说的各种产品满足，所以博客成为了当时的一种信息共享方式；在当时写博客的人应该多是互联网从事者，因为当时互联网使用率很低，也没有WordPress，Joomla，Hexo这样简单好用（相对而言）的建站工具，建站难度很高，个人建站的话，必须精通网络知识而且能够进行Web开发。即使博客能顺利建立，以后面临的另一个问题就是内容流通性差，互联网太广太大了，光靠搜索引擎不能使更多的信息流通起来，所以有很多的商业公司瞄准了这个市场，于是就诞生了以上的那些产品，它们各有特色，互为补充，几乎每一个国内的互联网使用者都有用过其中一二。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一个CS专业的大学生，书写博客是我们自身的需要，它不像在纸上书写，计算机显示技术能将我们想要表达的很多内容，清晰，明确的表现出来，举几个简单的例子：代码高亮，动态图演示等，都是书本不具有的，所以各种技术论坛，如CSDN、博客园、开源中国、Stack Overflow就应运而生，从一个方面来说，个人博客存在的意义已经不大了，但从另一个方面来说，个人博客与GitHub是一张好的名片。</p><blockquote><p>Talk is cheap. Show me the code.<br>—<em>Linus Torvalds</em></p></blockquote><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>博客建成就是你能看到的这个样子，功能基本齐全，评论功能由于体验十分糟糕所以弃用了 ，其他的一些功能觉得不必要就没有弄，如果你有什么问题和反馈可以从侧边栏使用邮件或者通过Github给我留言。<br>那些深度定制的博客十分惊艳，做之前可以先看看可以达到什么样的高度。</p><ul><li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">Hexo博客深度优化样例</a></li></ul><p>在我建站的过程中，参考了大量他们的经验分享，这里我也将我的建站经历写出来，以供参考。</p><p>建站的首先需要安装一些软件，安装过程为了准确，我直接引用Hexo文档的内容，建议直接参考<br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo的文档</a>，文档写的很漂亮。</p><hr><p><strong>以下关于Hexo配置的内容多来自Hexo官方网站</strong></p><p><em>我们正式开始</em></p><blockquote><p>什么是 Hexo？</p></blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><blockquote><p>安装</p></blockquote><p>安装 Hexo 只需几分钟时间，若您在安装过程中遇到问题或无法找到解决方式，请提交问题，我会尽力解决您的问题。</p><blockquote><p>安装前提</p></blockquote><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><p><code>Node.js</code></p><p><code>Git</code></p><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p><p><code>$ npm install -g hexo-cli</code></p><p>如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><blockquote><p>Mac 用户</p></blockquote><p>您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <code>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</code> 安装命令行工具。</p><blockquote><p>安装 Git</p></blockquote><ul><li><p>Windows：下载并安装 git.</p></li><li><p>Mac：使用 Homebrew, MacPorts ：<code>brew install git</code>;或下载安装程序安装。</p></li><li><p>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></p></li><li><p>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></p></li></ul><blockquote><p>Windows 用户</p></blockquote><p>由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。</p><blockquote><p>安装 Node.js</p></blockquote><p>安装 <code>Node.js</code> 的最佳方式是使用 nvm。</p><p><strong>cURL:</strong></p><p><code>$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</code></p><p><strong>Wget:</strong></p><p><code>$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</code></p><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><p><code>$ nvm install stable</code><br>或者您也可以下载 安装程序 来安装。</p><blockquote><p>Windows 用户</p></blockquote><p>对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。<br>另外，您也可以使用<code>Git Bash</code>，这是<code>git for windows</code>自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装<code>Node.js</code>。打开它的方法很简单，在任意位置单击右键，选择<code>“Git Bash Here”</code>即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用<code>Git Bash</code>来进行操作。</p><blockquote><p>安装 Hexo</p></blockquote><p>所有必备的应用程序安装完成后，即可使用<code>npm</code>安装 <code>Hexo</code>。</p><p><code>$ npm install -g hexo-cli</code></p><hr><p><em>到此为之你的Hexo博客所需的前提就已经准备完毕了，下一步需要生成一个Hexo文件并进行配置，一下内容同样来自Hexo的文档。</em></p><blockquote><p>建站</p></blockquote><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><p><code>$ hexo init &lt;folder&gt;</code></p><p><code>$ cd &lt;folder&gt;</code></p><p><code>$ npm install</code></p><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── <span class="keyword">package</span>.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><code>_config.yml</code>是网站的配置信息，您可以在此配置大部分的参数。</p><p><code>package.json</code><br>应用程序的信息。<code>EJS</code>, <code>Stylus</code> 和 <code>Markdown renderer</code> 已默认安装，您可以自由移除。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">""</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^0.2.4"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.1.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>scaffolds</p></blockquote><p>模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的markdown文件中默认填充的内容。<br>例如，如果您修改<code>scaffold/post.md</code>中的<code>Front-matter</code>内容，那么每次新建一篇文章时都会包含这个修改。</p><blockquote><p>source</p></blockquote><p>资源文件夹是存放用户资源的地方。除<code>_posts</code>文件夹之外，开头命名为 <code>_</code>(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code>文件夹，而其他文件会被拷贝过去。</p><blockquote><p>themes</p></blockquote><p>主题文件夹。Hexo 会根据主题来生成静态页面。后面我们会为我们的博客安装NexT主题。</p><hr><p><em>又一里程碑，这一个部分我们需要对我们的博客进行配置，新手就按照官方文档配置就可以，先看到结果，后续你可以进行复杂的配置和高度的个性化定制，在博客上花时间越多，你就越理解Hexo这个框架的逻辑。</em></p><blockquote><p>配置</p></blockquote><p><strong>写在前面的话，网站的配置对格式的要求非常严格，特别是缩进的要求，一般都是冒号之后一个空格，然后参数值，这个问题需要特别主要，最好使用Atom之类的编辑器来编辑，因为它会根据不同的缩进有不同的颜色颜色</strong></p><p>您可以在 <code>_config.yml</code> 中修改大部份的配置。</p><blockquote><p>网站</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>网站标题</td></tr><tr><td>subtitle</td><td>网站副标题</td></tr><tr><td>description</td><td>网站描述</td></tr><tr><td>author</td><td>您的名字</td></tr><tr><td>language</td><td>网站使用的语言 <strong><em>zh-Hans</em></strong></td></tr><tr><td>timezone</td><td>网站时区。Hexo 默认使用您电脑的时区，大陆使用的是 <strong><em>Asia/Shanghai</em></strong></td></tr></tbody></table><blockquote><p><a href="https://yangchaofu.cn">本站的网站配置</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: GALAXY</span><br><span class="line">subtitle:</span><br><span class="line">description: 永远年轻，永远热泪盈眶</span><br><span class="line">keywords:</span><br><span class="line">author: 沼泽星空</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure><blockquote><p>网址</p></blockquote><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>url</td><td>网址，用于连接你部署的域名</td><td></td></tr><tr><td>Root</td><td>网站根目录</td><td></td></tr><tr><td>permalink</td><td>文章的永久链接</td><td>格式    :year/:month/:day/:title/</td></tr><tr><td>permalink_defaults</td><td>永久链接中各部分的默认值</td></tr></tbody></table><blockquote><p><a href="https://yangchaofu.cn">本站的网址配置</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://https://yangchaofu.cn/</span><br><span class="line">root: /</span><br><span class="line">permalink: :title.html</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p>如果您的网站存放在子目录中，例如 <em><a href="http://yoursite.com/blog" target="_blank" rel="noopener">http://yoursite.com/blog</a></em>，则请将您的 url 设为 <em><a href="http://yoursite.com/blog" target="_blank" rel="noopener">http://yoursite.com/blog</a></em> 并把 root 设为 /blog/。</p><blockquote><p>目录</p></blockquote><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>source_dir</td><td>资源文件夹，这个文件夹用来存放内容。</td><td>source</td></tr><tr><td>public_dir</td><td>公共文件夹，这个文件夹用于存放生成的站点文件。</td><td>public</td></tr><tr><td>tag_dir</td><td>标签文件夹</td><td>tags</td></tr><tr><td>archive_dir</td><td>归档文件夹</td><td>archives</td></tr><tr><td>category_dir</td><td>分类文件夹</td><td>categories</td></tr><tr><td>code_dir</td><td>Include code 文件夹</td><td>downloads/code</td></tr><tr><td>i18n_dir</td><td>国际化（i18n）文件夹</td><td>:lang</td></tr><tr><td>skip_render</td><td>跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</td></tr></tbody></table><blockquote><p><a href="https://yangchaofu.cn">本站的目录配置</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p><em>如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。</em></p><blockquote><p>文章</p></blockquote><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>new_post_name</td><td>新文章的文件名称</td><td>:title.md</td></tr><tr><td>default_layout</td><td>预设布局</td><td>post</td></tr><tr><td>auto_spacing</td><td>在中文和英文之间加入空格</td><td>false</td></tr><tr><td>titlecase</td><td>把标题转换为 title case(大写)</td><td>false</td></tr><tr><td>external_link</td><td>在新标签中打开链接</td><td>true</td></tr><tr><td>filename_case</td><td>把文件名称转换为 (1) 小写或 (2) 大写</td><td>0</td></tr><tr><td>render_drafts</td><td>显示草稿</td><td>false</td></tr><tr><td>post_asset_folder</td><td>启动 Asset 文件夹</td><td>false</td></tr><tr><td>relative_link</td><td>把链接改为与根目录的相对位址</td><td>false</td></tr><tr><td>future</td><td>显示未来的文章</td><td>true</td></tr><tr><td>highlight</td><td>代码块的设置</td></tr></tbody></table><blockquote><p><a href="https://yangchaofu.cn">本站的文章配置</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Writing</span><br><span class="line">new_post_name: :title-:year-:month-:day.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br></pre></td></tr></table></figure><p><strong>相对地址</strong></p><p>默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为<code>example.com</code>,您有一篇文章名为<code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是绝对于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p><blockquote><p>分类 &amp; 标签</p></blockquote><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>default_category</td><td>默认分类</td><td>uncategorized</td></tr><tr><td>category_map</td><td>分类别名</td><td></td></tr><tr><td>tag_map</td><td>标签别名</td></tr></tbody></table><blockquote><p><a href="https://yangchaofu.cn">本站的分类&amp;标签配置</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br></pre></td></tr></table></figure><blockquote><p>日期 / 时间格式</p></blockquote><p>Hexo 使用 Moment.js 来解析和显示时间。</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>date_format</td><td>日期格式</td><td>YYYY-MM-DD</td></tr><tr><td>time_format</td><td>时间格式</td><td>H:mm:ss</td></tr></tbody></table><blockquote><p><a href="https://yangchaofu.cn">本站的日期/时间配置</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br></pre></td></tr></table></figure><blockquote><p>分页</p></blockquote><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>per_page</td><td>每页显示的文章量 (0 = 关闭分页功能)</td><td>10</td></tr><tr><td>pagination_dir</td><td>分页目录</td><td>page</td></tr></tbody></table><blockquote><p><a href="https://yangchaofu.cn">本站的分页配置</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br></pre></td></tr></table></figure><blockquote><p>扩展</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>theme</td><td>当前主题名称。值为false时禁用主题</td></tr><tr><td>deploy</td><td>部署部分的设置</td></tr></tbody></table><blockquote><p><a href="https://yangchaofu.cn">本站的扩展配置</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  //这里需要注意，请严格按照以下格式来书写，避免麻烦，如果不想暴漏密码可以找网上的其他教程</span><br><span class="line">  repo: https://yourname:yourpassword@github.com/yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><em>以上我基本就是把官方文档抄了一遍，然后对应给出我的网站的配置，初看官方文档如同课本一样，会觉得晦涩难懂，但配合着我的配置和我的博客的外观，你应该能够多数看明白，所以，你即使看不懂也要大概的过一遍，自己建博客的时候就不会两眼一发黑。</em></p><p><em>以上的配置有一个地方初次使用时需要注意，即主题，NexT主题是需要下载安装的，未下载了配置可能会出错，主题安装在后续给出说明。</em></p><hr><p><em>又完成了一个重要步骤，下一过程你就可以创建你的第一篇博文并部署测试了</em></p><p><strong>几个重要的命令写在前面，使用博客过程中你会大量使用的这几条命令，先混个眼熟，有些命令是缩写，括号内部给出全程</strong></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>hexo init</td><td>对一个文件夹进行初始化，进行Hexo的本地配置</td></tr><tr><td>hexo clean</td><td>对public中生成的文件进行删除</td></tr><tr><td>hexo g （generate）</td><td>根据sources文件中的博文和站点配置文件以及主题配置文件生成文件放入public</td></tr><tr><td>hexo d（deploy）</td><td>将public中的文件部署到_config.yml中deploy配置的地方</td></tr><tr><td>hexo s（server）</td><td>对博客进行本机测试，理解B/S结构程序的同学应该都明白，不明白不要紧</td></tr></tbody></table><p>_生成和部署命令可以混合使用，例如：<code>hexo g -d</code></p><blockquote><p>生成一篇本地新博文<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new "tiele"</span><br><span class="line">//事例</span><br><span class="line">hexo new 我的第一篇博文</span><br></pre></td></tr></table></figure></p></blockquote><p>该命令会生成一篇位于source/_posts/的博文，生成的博文会根据<code>_config.yml</code>的<code>new_post_name:</code>来生成博文名；还会根据 <em>scaffolds</em> 模版文件中的<code>post</code>中的内容对新建的博文进行填充一部分内容，你可以自己定义内部的内容。</p><p>比如本博客的博文名生成方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :title-:year-:month-:day.md # File name of new posts</span><br></pre></td></tr></table></figure><p>根据以上事例就会得到这样一个博文名字：</p><p><strong><em>我的第一篇博文-2018年-5月-10日</em></strong></p><p>然后根据<code>scaffolds</code>中的post文件家生成的填充内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我的第一篇博文-2018年-5月-10日</span><br><span class="line">comments: true      //开启评论功能，需要有外部的文件支持，由于体验不好所以，本博客暂时没有使用评论系统</span><br><span class="line">date: 2018-05-10 17:24:13 //创建时间</span><br><span class="line">tags:   //标签</span><br><span class="line">  - Hexo</span><br><span class="line">  - NexT</span><br><span class="line">categories: //分类，分类和标签在官方文档中有很好的说明</span><br><span class="line">  - 随笔</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>后面你就可以写你的博文内容了，Hexo默认使用的是Markdown来作为内容书写格式，你需要简单的学习一下Markdown语法，但是不是非常困难，可以依托互联网快速学习，其中有很多深入的东西，比如画图和数学公式可以稍微放一下，主要对标题、序列、代码、图片、超链接、表格、加粗、斜体等了解即可，当然，这么优雅的语言深入学习是必须的，还有，书写的时候可以配合html来做到更好的效果，官方也为我们提供了一些特别的标签，可以参考官方文档，使用一些插件，我们可以在我们的博文中引入图片和视频这些比较高大上的东西，这个内容在后续会单独说说道。<br>注意一点，博文会有阅读全部和部分的摘要两个方面，怎么分割呢，使用 <code>&lt;!-- more --&gt;</code>来实现</p><hr><p>第一篇博文写好了之后，就是使用控制台或者Git Bash进行发布的时候了，比如说我们使用Windows，我们用控制台进入到我们博客站点所在的文件夹下，然后进行<code>hexo g</code>命令生成文件，然后使用<code>hexo s</code>，在浏览器中输入<code>localhost:4000</code>进入预览，然后进行更改，觉得没有问题之后使用<code>hexo d</code>进行部署到GitHub的仓库中，在浏览器中输入yourgithubname.github.io即可进行访问。<br>你的第一篇博文就诞生了，但是官方主题相对第三方而言差了一点，所以我们复习要对它进行主题的更改，这里就需要安装NexT这个优雅的主题了，这里希望大家照着NexT的官方文档一步一步来，弄不清楚多看几遍，网络上的好多内容参差不齐，官方文档是相对而言最好的参考，质量有保证。<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT官方文档</a></p><p>好，到这一步假设你已经安装好了NexT，并进行了一些配置，但是你肯定忘了一些，或者根本无从下手的，那么再从这几个地方看看，你配置了吗？</p><ul><li><a href="http://theme-next.iissnan.com/getting-started.html#select-scheme" target="_blank" rel="noopener">主题设置</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html#menu-settings" target="_blank" rel="noopener">菜单界面</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html#sidebar-settings" target="_blank" rel="noopener">侧边栏</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html#avatar-setting" target="_blank" rel="noopener">头像设置</a></li><li><a href="https://www.jianshu.com/p/baea8c95e39b" target="_blank" rel="noopener">统计功能</a></li><li><a href="http://theme-next.iissnan.com/theme-settings.html#author-sites" target="_blank" rel="noopener">不算子统计</a></li><li><a href="https://www.ezlippi.com/blog/2017/02/hexo-search.html" target="_blank" rel="noopener">本地搜索</a></li><li><a href="http://theme-next.iissnan.com/theme-settings.html#tags-page" target="_blank" rel="noopener">菜单页面的配置</a></li><li><a href="http://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme" target="_blank" rel="noopener">代码高亮</a></li><li><a href="http://theme-next.iissnan.com/theme-settings.html#author-sites" target="_blank" rel="noopener">外部链接</a></li></ul><p>根据NexT官方文档对该主题进行配置之后，你的博客将具有侧边栏的头像，侧边栏的链接,同时你的菜单将拥有关于，标签，归档，本地搜索这些菜单选项，已经十分强大了，基本上我们的博客就建立完毕了，如果你没有更多的要求，那么，已经可以收手了，博客主要还是要有内容的保证</p><hr><blockquote><p>深度的定制</p></blockquote><p>对于希望博客更加好用好看的同学，可以参考以下两个内容，第一个功能非常的繁多，可以从中选择自己喜欢的进行配置，而第二个就需要特别隆重的推荐一下了，我觉得这是Hexo建站的巅峰，我见过做过最好的一个，而且毫不吝啬的给出来深度定制的教程，好多内容可以从中参考，希望自己的博客也能如此漂亮的同学可以通过他给出的文档得到满足。</p><ul><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">Hexo+NexT的众多配置选项</a></li><li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">Hexo博客深度优化</a><br>其中第二个强烈建议大家去预览看看，做的很漂亮，而且很工整，对大家后面书写博客和对博客个性化有巨大的帮助。</li></ul><p>还有一个问题是文件的存储问题，一般网络上都是使用网络存储空间然后引用的方法，这里推荐大家一个存储的地方，目前是免费的。</p><ul><li><a href="https://tu.aixinxi.net/index.php" target="_blank" rel="noopener">爱信息图床</a></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>牛顿曾经说过：我之所以能看的远，是因为我站在了巨人的肩膀上；IT界也有一种说法叫不到万不得已，不自己“造轮子”，其实他们是一样的概念，知识是人类巨大的宝库，参考别人的经验是一个人一生学习的技能。</p><ul><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo中文文档</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT官方文档</a></li><li><a href="https://blog.csdn.net/lijiajun95/article/details/53862528" target="_blank" rel="noopener">最详细的Hexo Next主题配置教程</a></li><li><a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">从零建站</a></li><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">Hexo+NexT的众多配置选项</a></li><li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">Hexo博客深度优化</a></li><li><a href="https://www.jianshu.com/p/f869d1940985" target="_blank" rel="noopener">玩转Hexo博客之Next</a></li><li><a href="https://www.jianshu.com/p/baea8c95e39b" target="_blank" rel="noopener">Hexo添加字数统计、阅读时长</a></li><li><a href="https://segmentfault.com/q/1010000009361385" target="_blank" rel="noopener">hexo搭建的博客如何给文章分类（NEXT主题）</a></li><li><a href="https://www.jianshu.com/p/f9ae2c892e44" target="_blank" rel="noopener">next主题之第三方评论系统</a></li><li><a href="https://www.jianshu.com/p/9a56f7c13a79" target="_blank" rel="noopener">Hexo Docs基本用法</a></li><li><a href="http://wingjay.com/" target="_blank" rel="noopener">建站启蒙</a></li><li><a href="https://notes.wanghao.work/" target="_blank" rel="noopener">部分内容参考</a></li><li><a href="https://www.jianshu.com/p/5d5931289c09" target="_blank" rel="noopener">Next主题(Hexo)</a></li><li><a href="https://segmentfault.com/a/1190000013660164#articleHeader1" target="_blank" rel="noopener">hexo搭建个人博客–NexT主题优化</a></li><li><a href="https://blog.csdn.net/u013384788/article/details/74079890" target="_blank" rel="noopener">Hexo博客中插入音乐</a></li><li><a href="http://www.ehcoo.com/seo.html" target="_blank" rel="noopener">Hexo-next百度和谷歌搜索优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人博客是继Email、BBS、IM之后的第四种网络信息传播方式，是一个区别于当前流行的（QQ空间，微信朋友圈，微信公众号，微博，贴吧，知乎，简书，论坛）信息分享平台，他有强烈的个人标识和非常高的个性化。说了这么多，我想说的是我搭建了一个博客，我有话要说，:muscle:&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://yangchaofu.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Hexo" scheme="https://yangchaofu.cn/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://yangchaofu.cn/tags/NexT/"/>
    
      <category term="博客" scheme="https://yangchaofu.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>音乐|视频</title>
    <link href="https://yangchaofu.cn/%E9%9F%B3%E4%B9%90%E5%92%8C%E8%A7%86%E9%A2%91%E6%B5%8B%E8%AF%95.html"/>
    <id>https://yangchaofu.cn/音乐和视频测试.html</id>
    <published>2018-05-09T15:09:47.000Z</published>
    <updated>2019-02-09T13:44:33.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <div id="aplayer-yYUznrZx" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-yYUznrZx"),            narrow: false,            autoplay: false,            showlrc: 3,            music: {              title: "给未来的自己",              author: "杨宗纬",              url: "http://lc-gm2oqrvg.cn-n1.lcfile.com/825ece89b40aa0eca95f.mp3",              pic: "http://t1.aixinxi.net/o_1cd3oig311k0i19ig1dflpmqg3ba.jpg-w.jpg",              lrc: "http://lc-gm2oqrvg.cn-n1.lcfile.com/f692d34c809329b58266.lrc"            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><div align="center">音乐就是最好的语言</div><a id="more"></a>        <div id="aplayer-lEQhXUvQ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-lEQhXUvQ"),            narrow: false,            autoplay: false,            showlrc: 3,            music: {              title: "浮生",              author: "刘莱斯",              url: "http://t1.aixinxi.net/o_1d0br5gb21qij1s7bcbr10fc13pqa.mp3",              pic: "http://p2.music.126.net/l-Ev4NbIeolk9QoJLtRzTQ==/109951162819579041.jpg",              lrc: "http://lc-gm2oqrvg.cn-n1.lcfile.com/d79d3f78e9fa160f1efd.lrc"            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><div align="center">浮生若梦, 为欢几何</div>        <div id="aplayer-iGugIKVi" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","width":"50%","music":[{"title":"世界第一等","author":"浪哥","url":"http://lc-gm2oqrvg.cn-n1.lcfile.com/90627863f7b7628b30e7.mp3","pic":"http://lc-gm2oqrvg.cn-n1.lcfile.com/3a56a50657d1226f84c0.jpg","lrc":"http://lc-gm2oqrvg.cn-n1.lcfile.com/ea6eca9aaa075cdfe469.lrc"},{"title":"藏","author":"徐梦圆,双笙","url":"http://lc-gm2oqrvg.cn-n1.lcfile.com/76ec9581de7c10fa304d.mp3","pic":"http://p1.music.126.net/9cySfhHshoKksSkAxwVVqw==/109951163175751210.jpg","lrc":"http://lc-gm2oqrvg.cn-n1.lcfile.com/a31460d8a34a2b9bfe4d.lrc"}]};  options.element = document.getElementById("aplayer-iGugIKVi");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"http://hc.yinyuetai.com/uploads/videos/common/EA5C013B0C230B2FB98CD9AE6D08CEDF.flv?sc=78c58aee070a719f&br=777&vid=548425&aid=123&area=US&vst=2.mp4","pic":"https://i.loli.net/2018/05/10/5af32395de90a.png"},"danmaku":{"id":"11232345134","api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><div align="center">Viva La Vida（生命万岁）站立的角度不一样，就能看到不一样的世界</div>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-yYUznrZx&quot; class=&quot;aplayer aplayer-tag-marker&quot; style=&quot;margin-bottom: 20px;&quot;&gt;
            &lt;pre class=&quot;aplayer-lrc-content&quot;&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;script&gt;
          var ap = new APlayer({
            element: document.getElementById(&quot;aplayer-yYUznrZx&quot;),
            narrow: false,
            autoplay: false,
            showlrc: 3,
            music: {
              title: &quot;给未来的自己&quot;,
              author: &quot;杨宗纬&quot;,
              url: &quot;http://lc-gm2oqrvg.cn-n1.lcfile.com/825ece89b40aa0eca95f.mp3&quot;,
              pic: &quot;http://t1.aixinxi.net/o_1cd3oig311k0i19ig1dflpmqg3ba.jpg-w.jpg&quot;,
              lrc: &quot;http://lc-gm2oqrvg.cn-n1.lcfile.com/f692d34c809329b58266.lrc&quot;
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        &lt;/script&gt;
&lt;div align=&quot;center&quot;&gt;音乐就是最好的语言&lt;/div&gt;
    
    </summary>
    
      <category term="随行" scheme="https://yangchaofu.cn/categories/%E9%9A%8F%E8%A1%8C/"/>
    
    
      <category term="音乐" scheme="https://yangchaofu.cn/tags/%E9%9F%B3%E4%B9%90/"/>
    
      <category term="视频" scheme="https://yangchaofu.cn/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>重学Java：基本概念</title>
    <link href="https://yangchaofu.cn/%E9%87%8D%E5%AD%A6Java%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"/>
    <id>https://yangchaofu.cn/重学Java：基本概念.html</id>
    <published>2018-05-07T02:58:45.000Z</published>
    <updated>2019-01-03T12:57:17.685Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java的复习工作已经在进行，是为了后面的Web开发和安卓学习打下基础。Java语言是一门强大的语言，Java的出现是在C++语言之后，对C++语言的各种缺陷（被认为让人难以理解或者容易产生逻辑错误的地方）进行的各种改进而产生的一门面向对象的语言，它可以说是对C++语言的一次优秀的革命，使得C++这门强大的，扩展了强大的C语言，具有面向对象、面向过程两种设计模式的语言，变成了纯面向对象的语言，取消了指针（内存地址操作）这个比较难以弄懂的语言特征，并且带有诸如异常处理等高级特征，一经问世，备受追捧，久经沙场之后，走到了程序语言的顶峰，其强大特性直接或间接催生了C#这门与之十分相似的强大程序语言。</p><a id="more"></a><h3 id="Java中几个关键字的作用需要去了解一下-以前没有用过"><a href="#Java中几个关键字的作用需要去了解一下-以前没有用过" class="headerlink" title="Java中几个关键字的作用需要去了解一下,以前没有用过"></a>Java中几个关键字的作用需要去了解一下,以前没有用过</h3><ul><li>删除线表示原来不知道，后来看了对应的资料，有所了解</li></ul><p>对象相关</p><ul><li><del>implements</del> 用于实现接口，接口更像是一种约定，一个类可以实现多个接口</li><li><del>instanceof</del> 用于判断一个引用的类对象</li></ul><p>方法变量和类修饰符</p><ul><li><del>abstract</del>  用于修饰抽象类，抽象类是具有空方法的类，抽象类不能被实例化，抽象类的继承同普通类，抽象类和接口的区别后面会提到</li><li><code>transient</code></li><li><code>volatile</code></li><li><code>strcitfp</code></li></ul><h3 id="Java中变量作用域"><a href="#Java中变量作用域" class="headerlink" title="Java中变量作用域"></a>Java中变量作用域</h3><ul><li>一个变量位于类内部,成为字段或者属性,成员变量,Field</li><li>声明在方法内的变量,叫做局部变量,不能在类中使用这个变量</li><li>当一个变量被 <code>final</code> 修饰时,该变量只有一侧赋值机会,可用作常量的定义和设置不被继承</li></ul><h3 id="Java中的运算"><a href="#Java中的运算" class="headerlink" title="Java中的运算"></a>Java中的运算</h3><ul><li>同种变量类型运行(包括整形和浮点型),运算结果取类型较大的</li><li>逻辑运算分为长短两种,长逻辑需要两边都运算,短逻辑只需一边运算,逻辑或需要两边运算</li><li>位运算有位或和位与两种操作</li><li>位运算左移相当于乘2,右移相当于除2</li><li>有符号的数据左右移位,移位之后还是对应的符号;不带符号的数据左右移位,正负改变</li></ul><h3 id="Java中数组的使用"><a href="#Java中数组的使用" class="headerlink" title="Java中数组的使用"></a>Java中数组的使用</h3><ul><li><code>Array.toString</code>方法用来打印十分方便</li><li><code>System.arraycopy(src, srcPos, dest, destPos, lengtObject)</code>的用法,<br><code>@parm src</code>: 源数组<br><code>@parm srcPos</code>: 从源数组复制数据的起始位置<br><code>@parm dest</code>: 目标数组<br><code>@parm destPos</code>: 复制到目标数组的起始位置<br><code>@parm lengtObject</code>: 复制的长度<br>的用法</li><li><code>Arrays</code>的各种用法</li></ul><ol><li>coypOfRang — 数组复制</li><li>toString — 转换为字符串</li><li>sort —排序</li><li>binarySearch — 搜索</li><li>equals — 判断是否相等</li><li>fill — 填充数组</li></ol><ul><li>Java中Arrays. sort使用了两种排序方法，快速排序和优化的合并排序。<br>快速排序主要是对哪些基本类型数据（<code>int</code>,<code>short</code>,<code>long</code>等）排序。<br>而合并排序用于对对象类型进行排序。原因：<br>使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的。<br>这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。<br>对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的，<br>因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的<br>顺序与排序前一直。另外一个原因是由于合并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，移动是简单的，只是引用的转换，但是比较相对更加耗时。合并排序的时间复杂度是<code>n*logn</code>, 快速排序的平均时间复杂度也是<code>n*logn</code>，但是合并排序的需要额外的<code>n个引用</code>的空间。</li></ul><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><ul><li>引用的概念，如果一个变量的类型是 类类型，而非基本类型，那么该变量又叫做引用。例:<code>new XXX()</code>;就是一个引用,它不是基本类型,而是 类类型.</li><li><p><code>Object Object = new Object()</code>;<br>Object这个变量是Object类型，又叫做引用<br>=的意思指的Object这个引用代表右侧创建的对象<br>“代表” 在面向对象里，又叫做“指向”.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  String objectName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Object();</span><br><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个引用同时时间可以指向多个引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object Object1 = <span class="keyword">new</span> Object();</span><br><span class="line">Object object2 = object1;  <span class="comment">//Object2指向Object1所指向的对象</span></span><br><span class="line">Object object3 = object1;</span><br><span class="line">Object object4 = object1;</span><br><span class="line">Object object5 = object4;</span><br><span class="line"><span class="comment">//所有的object1,2,3,4,5同时指向一个Object对象</span></span><br></pre></td></tr></table></figure></li><li><p>方法重载的概念,重载就是同样名字的方法可以写多个,每个方法有不同的参数列表,在使用是,JVM根据传人的参数数量自动识别并调用对应的方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> returnType <span class="title">mehod</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> returnType <span class="title">mehod</span><span class="params">(type a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> returnType <span class="title">mehod</span><span class="params">(type x,type y)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>构造方法的概念每一个类都有一个构造方法,构造方法可以重载,不写时默认有一个无参构造方法,构造方法名与类名相同,构造方法无返回值,可见性为<code>public</code>,当使用<code>new</code>关键字引用一个对象时,默认调用该对象的构造方法.</p></li><li>使用<code>static</code>修饰的的方法或者属性,叫做类方法和类属性,一个被声明静态的属性和方法,被所有对象共享,建议使用类来获取该属性和方法,一突出其类属性和类方法的概念,与之对应的叫做对象属性和对象方法.</li><li>Java中使用文档注释，可以才新建项目的时候勾选添加注释，也可以是使用快捷键<code>Alt+Shift+J</code>键进行添加,注释的基本写法如下,使用官方提供的注释标识,常用的如下表:</li></ul><table><thead><tr><th>标记</th><th>标识</th><th>用于</th></tr></thead><tbody><tr><td>@author</td><td>作者</td><td>类注释</td></tr><tr><td>@version</td><td>当前软件版本</td><td>类注释</td></tr><tr><td>@since</td><td>JDK版本</td><td>类注释</td></tr><tr><td>@see</td><td>链接到其他Javadoc</td><td>类注释</td></tr><tr><td>{@link}</td><td>统@see,使用更加自由,可以在前面添加描述信息</td><td>类注释</td></tr><tr><td>@param</td><td>参数详解,后面跟参数名</td><td>方法注释</td></tr><tr><td>@return</td><td>返回值详解</td><td>方法注释</td></tr></tbody></table><ul><li>单例模式具有两种写法，使用单例模式在JVM中只能实例化一个对象，在一些特定场景使用单例模式是必要的，比如在GUI中使用的的Frame，在一些设计场景中的只有一个的对象。<br>单例模式有两种实现方式，下面的代码分别对这两只模式进行解读。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="comment">//私有化构造方法，使对象无法示例化新的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Object1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//实例化一个该类的对象</span></span><br><span class="line">  <span class="keyword">private</span> Object instance  = <span class="keyword">new</span> Object()；</span><br><span class="line">  <span class="comment">//获取该类的单例</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;s</span><br><span class="line">  <span class="comment">//私有化构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Object</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//定义一个本类型的属性</span></span><br><span class="line">  <span class="keyword">private</span> Object instance;</span><br><span class="line">  <span class="comment">//获取该类的单例</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">      instace = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>两种模式使用时的选择，如果在构造方法中有大量的需要初始化的东西，代码量大的情况下，使用饿汉式可以减少时间，提高效率；懒汉式具有线程安全的考虑。</p><ul><li>枚举类型。枚举也是一种类，是对一些常量的定义，最简单的例子，一个星期五天，一年四个季节使用枚举可以表述的更清晰（相比于使用1、2、3、4）这样的样例还有很多，实际使用的时候需要多作考虑。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season&#123;</span><br><span class="line">  SPRING,SUMMER,AUTUMN,WINTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h3><ul><li><p>接口的意义，接口相当于一种约定，实现某一个接口就必须要实现该接口中的方法。Java中一个子类只能继承一个父类，但是可以实现多个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntFace</span></span>&#123;</span><br><span class="line">  <span class="comment">//继承该接口必须实现method方法</span></span><br><span class="line">  <span class="function">pulic <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用implements关键字实现接口，实现接口中的method方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obejcet</span> <span class="keyword">implements</span> <span class="title">IntFace</span></span>&#123;</span><br><span class="line">  <span class="comment">//重载接口的方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用类型和对象的概念，如何一个非基本数据类型定义出来的变量都称为引用，而使用new 关键字调用构造方法生成的，就叫做对象类型。引用类型转换的指向可以由子类向父类转换。这样是一定成功的，比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java中所有的类都是Object的子类，所以以一个这样的例子来介绍引用类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Obejcet</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//理解方法：把右边的当作左边的用，看行不行得通</span></span><br><span class="line"><span class="comment">//该例中，把对象类型A当作父类性Object是完全说的通的，所以可行</span></span><br><span class="line"></span><br><span class="line">Obejcet obj = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure></li><li><p>如何判断一个引用类型的的对象，使用instanceof关键字可以确定一个引用指向的对象类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object1();</span><br><span class="line">System.out.print(obj <span class="keyword">instanceof</span> Object);</span><br></pre></td></tr></table></figure></li><li><p>重写和覆盖<br>与重写类似，方法的重写是子类覆盖父类的对象方法 ；<br>隐藏，就是子类覆盖父类的类方法。</p></li><li>super关键字可以在子类中调用父类的有参构造方法（子类默认调用父类的无参构造方法而且是一定会调用），使用super关键字可以调用父类的属性和方法。</li><li>Object是所有子类的父类，Object有如下方法：<br><div align="center"><br>Object具有的方法</div></li></ul><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>toString</td><td>对象的字符串表达</td></tr><tr><td>finalize</td><td>垃圾回收时调用该方法</td></tr><tr><td>equals</td><td>用于判断两个对象的内容是否相等</td></tr><tr><td>hashCode</td><td></td></tr><tr><td>wait、notify，notifyAll</td><td>线程同步方法</td></tr><tr><td>getClass</td><td>返回一个对象的类对象</td></tr></tbody></table><p></p><ul><li>final关键字修饰类，方法，基本类型变量和引用类型时有不同的含义</li></ul><table><thead><tr><th>修饰</th><th>意义</th></tr></thead><tbody><tr><td>类</td><td>该类不能被继承</td></tr><tr><td>方法</td><td>该方法不能被重写</td></tr><tr><td>基本类型变量</td><td>该基本类型变量只能被赋值一次</td></tr><tr><td>引用</td><td>该引用只有一次指向对象的机会</td></tr></tbody></table><ul><li>抽象类</li></ul><p>*来自<a href="www.how2j.cn">how2.cn</a>抽象类内容<br>在类中声明一个方法，这个方法没有实现体，是一个“空”方法，这样的方法就叫抽象方法，使用修饰符“abstract” 当一个类有抽象方法的时候，该类必须被声明为抽象类。</p><ol><li>继承抽象类的子类<strong>必须提供</strong>不一样的抽象方法；</li><li>抽象类不能被实例化；</li><li>抽象类和接口的区别</li></ol><table><thead><tr><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>子类只能继承一个抽象类，不能继承多个，抽象类的继承同普通类</td><td>子类可以实现多个接口</td></tr><tr><td>抽象类可以被定义 public、protected、package、private，静态和非静态属性</td><td>接口只能被定义为public、静态和final的，即使书写的时候没有用到public static final。。也会自动添加上去</td></tr></tbody></table><p>接口当成一个协议，实现了这个接口（协议）的类就应该实现接口中的方法（协议内的条例），接口是约束调用本接口的类而不是给类提供能力。<br>抽象类则是让继承此类的子类一定要实现某个方法。例如取快递是一个抽象类，签收是抽象方法，那么一定要实现签收方法才能完成取快递。</p><p>本部分为Java的基础内容，记录并常回顾。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java的复习工作已经在进行，是为了后面的Web开发和安卓学习打下基础。Java语言是一门强大的语言，Java的出现是在C++语言之后，对C++语言的各种缺陷（被认为让人难以理解或者容易产生逻辑错误的地方）进行的各种改进而产生的一门面向对象的语言，它可以说是对C++语言的一次优秀的革命，使得C++这门强大的，扩展了强大的C语言，具有面向对象、面向过程两种设计模式的语言，变成了纯面向对象的语言，取消了指针（内存地址操作）这个比较难以弄懂的语言特征，并且带有诸如异常处理等高级特征，一经问世，备受追捧，久经沙场之后，走到了程序语言的顶峰，其强大特性直接或间接催生了C#这门与之十分相似的强大程序语言。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://yangchaofu.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://yangchaofu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="https://yangchaofu.cn/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B.html"/>
    <id>https://yangchaofu.cn/新的开始.html</id>
    <published>2018-04-13T15:57:12.000Z</published>
    <updated>2019-01-03T12:58:19.411Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>仰望星空，脚踏实地。突然说出这句话可能有点突兀，但是经历了岁月二十二载的洗礼，对这几个字的理解也越发深刻，不断的跌倒，不断的再出发，让自己的内心也越发的坚强和健全，新的开始不是彻底与过去说再见，也不去否定过去的自己，而是以一种更加积极的态度去面对生活这个难题，迎接新的开始</p><a id="more"></a><p>一直想要一个自己的博客，毕竟自己学习计科专业，经常书写技术总结是很必要的。自己在这个专业摸爬滚打了三年了，期间有所得，有所失，但是凡事只要肯付出时间和精力，总能做成。进入大学的这几年，心理变化是起伏不定的，这几年时光是生命中最美好的时光，自己也慢慢学会了与自己相处，与世界相处，内心深处开始不断的悦纳自己，同时悦纳世界，余生的目标是尽自己最大的努力把生活过好，能做到什么程度无所谓，只希望以后回头看看自己走过的路，笑着对自己说：不枉人间走一遭。</p><h3 id="回顾过去的三年"><a href="#回顾过去的三年" class="headerlink" title="回顾过去的三年"></a>回顾过去的三年</h3><p>三年的时间转瞬即逝，人最可悲的事情往往是事后才明白当初应该走什么路。事实证明，我选了一个我喜欢的专业，我愿意为之付出时间并觉得这是值得的，这比什么都重要。至于学校的问题我想大可不必去过多的考虑，我觉得一所好的学校能够给一个学生超前的思想境界，而相反也一样，一所差的学校会限制学生的观念、境界和想法，但这不是绝对的，思想是自由的，人也是自由的，正如《肖申克的救赎》里瑞德说的：“有些鸟儿是永远关不住的，因为它们的每一片羽翼上都沾满了自由的光辉！”</p><p>三年来，有懈怠的时光，也有努力的时光，对于我来说，它们同样的难能可贵，这些时间堆砌出了我的性格，我的阅历和我的能力，同样还有我的懒惰，我的不足和我的缺陷。三年时间学了很多东西，有真心想学的，有学了忘了的，也有学了之后，对我的生活和想法产生了巨大影响的，我开始有了计算机思维，懂得用机器去解决生活中的实际问题，并一直在路上。</p><p>也追逐了自己的信仰，走上了无产阶级政党的道路，正如马克思在《青年在选择职业的考虑》中所说的：“如果我们选择了最能为人类福利而劳动的职业，那么，重担就不能把我们压倒，因为这是为大家而献身；那时我们所感到的就不是可怜的、有限的、自私的乐趣，我们的幸福将属于千百万人，我们的事业将默默地、但是永恒发挥作用地存在下去，面对我们的骨灰，高尚的人们将洒下热泪。”而我的理想，我想没有比这更好的解释了，那些默默无闻的推动了整个人类进程的人，那些为国家建设，民族振兴而付出努力的人，无论商人、政客、教师、医生，农民，工人，他们的生命是光辉的，他们为取得自己生命的意义而不懈努力，这里想到一句话，在《钢铁是怎样炼成的》一书中，奥斯特洛夫斯基说过：“人最宝贵的东西是生命,生命对于每个人都只有一次. 一个人的一生应该是这样度过的：当他回首往事的时候，他不会因为虚度年华而悔恨，也不会因为碌碌无为而羞耻；这样，在临死的时候，他就能够说：我的整个生命和全部精力，都已经献给世界上最壮丽的事业——为人类的解放而斗争。”这些影响着我个人的思想的，无论文字，语录还是那些对我言传身教的人，塑造了我的世界观、人生观和价值观，并将在我的一生中，持续下去。</p><h3 id="对剩余大学时光的一些规划"><a href="#对剩余大学时光的一些规划" class="headerlink" title="对剩余大学时光的一些规划"></a>对剩余大学时光的一些规划</h3><p>人生的道路上需要不断的思考，反省，但如何思考，如何反省这是一个问题。人除了需要物质生活之外，还需要精神食量，而最好的精神食量，就是那些好书，那些给予人以改变，让人看清物质本原，指导人前进的有思想的书；那些给予我们解决现实生活中各种问题的，告诉我们物质变化逻辑的技术书；那些告诉我们生活色彩，讲述现实的故事书，那些叙述史实，总结前人故事的历史书等等。这些书让我们有自己独立的灵魂，能够看到自己存在的意义，知道世界变化的客观规律，并告诉我们什么是善，什么是恶。<br>所以，对于大学剩下的时光，第一要求就是读书，无论能不能读懂，都需要把那些公认的好书，读一遍再走，不然浪费了大学的名头，也侮辱了大学生这个词。后续的读书计划及读书心得将在后面的博文里出现。</p><p>“人应该有一技之长”，这是诺顿对安迪所说的话，而这是我生活中信奉的圣经，无论在那，无论干什么，人应该有一技之长，并且知根知底，所以，我把计算机技术当作我的那一技之长，我需要为之付出的努力，将变成人生中的积累，不断沉淀。那要怎么将它变成一技之长呢，唯有合理的学习和提升安排才能做到。</p><p>提升自己的外语水平，这一点和前面的对应，对于我来说，英语的重要性不言而喻，我必须学好英语，否则就是空谈，不踩在巨人的肩膀上，看到的永远是无尽的山峦险岳，而巨人用英语。</p><p>时间易逝难追，对于我这样一出生就没有拿到一手好牌的人，只能打好手中的烂牌。上天对我们唯一的公平就是时间。时间如此宝贵，那人生不能走一步算一步，及早的规划人生是重要的，我想我以后的生活可能会艰难的多，但只要用心了，认真的考虑之后就没有问题。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>“心怀希望是一件好事，也许是最好的事，心怀希望，就永远有希望”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;仰望星空，脚踏实地。突然说出这句话可能有点突兀，但是经历了岁月二十二载的洗礼，对这几个字的理解也越发深刻，不断的跌倒，不断的再出发，让自己的内心也越发的坚强和健全，新的开始不是彻底与过去说再见，也不去否定过去的自己，而是以一种更加积极的态度去面对生活这个难题，迎接新的开始&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://yangchaofu.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="想的比较多" scheme="https://yangchaofu.cn/tags/%E6%83%B3%E7%9A%84%E6%AF%94%E8%BE%83%E5%A4%9A/"/>
    
  </entry>
  
</feed>
