<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[静待花开]]></title>
    <url>%2F%E9%9D%99%E5%BE%85%E8%8A%B1%E5%BC%80.html</url>
    <content type="text"><![CDATA[这是一篇记录心情的文章,把这些东西写出来感觉自己心里面好受一点.这次和自己对话的主题是,我现在到底处于一种什么境况,我能怎么面对或者如何熬过,我不喜欢反问自己,我总喜欢按照自己的想法来行事,事实证明这是有问题的,无论于己还是于人,都没法取得好的结果,我想我应该换一种思维方式和处世的方式,主动一点去接触社会,获取更多的资讯,通过自己对信息的敏感度,整合出来对自己有利的东西,然后充分把握机会,我总是把握不住机会,不知为何,从高考开始,到大学的四六级,到大四的校招找工作,到公务员考试,到现在的工作岗位,一切的一切,都在充分的说明我自闭的性格,对,我把自己关了起来,不想要被打扰,可世界太繁杂,来自内外的声音让我不得不寝食难安,让我不得安宁,我为此付出的精力,付出的时间,都是巨大的,我会从几个方面来求证这个观点. 首先,入党给我带来的一些不顺心的事情,本来评优入党,这并没有什么问题,但往往事不如人愿,就比如这次的党组织关系的转移,费尽周折,受尽白眼,感受到了来自党组织的各种不体谅,党员就是,无论如何,都应该把党放在第一位,这话理论上来说没有问题,但是终究没几个人能做到,却偏要要求别人能做到,对于其个人而言,做好这些事就是他们的全部,包括工作,包括党风的传承,但不知对于我来说,这仅仅只是我人生中的一部分,而且作为一个刚毕业之人,我还要负责养活自己的重任,承当赔付贷款的重任,实在经受不起如此折腾,但又退而不可,进而不得,实属艰难. 其二,工作的机会全部错失,大四不知为何,偏偏像染了瘟神一般,颈椎突然就不行了,这对本来还充满雄心壮志的我而言,是无法承受的,低落,失望的情绪蔓延,慢慢的迷失了自己,不再有任何学习的欲望和对未来的期望,完完全全的荒废了大学的最后一年,这也是为何现在如此艰难的原因之一,不知为何养成的高不成低不就的性格,错失众多机会,而后勉强夹缝中生存,活了下来,避免毕业之后沦落街头的惨状,也算是一小安慰,但实属杯水车薪,不足挂齿.现在在社会上感受到了社会对应届毕业生的刁难,不待见,特别是对像我们这样的二本毕业生来说.更是艰难无比,只能勉强苟活,唯一的正途似乎就是考公务员,考事业单位,进入体制,至于学的所谓专业知识,其实似乎都是狗屁,中国从来不是一个重视技术的国家,当官才能光宗耀祖,其他似乎都是狗屁,却也如此,可我到今日才明白这些至理,还曾妄想以技术改变世界和国家的面貌,实属不了解详情.]]></content>
  </entry>
  <entry>
    <title><![CDATA[二维码生成与解析：jQuery-qrcode]]></title>
    <url>%2F%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E8%A7%A3%E6%9E%90%EF%BC%9AjQuery-qrcode.html</url>
    <content type="text"><![CDATA[前面两篇博文讲述了使用Java在本地生成和解析二维码，其生成的二维码可以用到Web应用中，但是在Web应用中有一种更简单的生成方法就是使用jQuery-qrcode来生成二维码，本片博文就介绍使用这种方法来生成二维码。 准备工作本次项目是一个Web项目，可以使用静态的HTML来生成，但是为了更贴近实际使用情况，我使用Java EE项目来演示（使用JSP技术），项目结构很简单，只有一个jsp文件和一个js文件夹，我们将jquery.min.js和jquery.qrcode.min.js两个文件放到项目的WebContent目录的js文件夹之下。 所说的两个js文件在网盘以下中给出： 百度网盘：链接：https://pan.baidu.com/s/1vQZRPbRKzaQg3-XqsRc-Jw提取码：y8cq 创建项目使用eclipse-javaee版本创建一个动态web项目，项目目录如图所示： 经过测试之后发现一个问题就是在jQuery-qrcode自带的编码是utf16，无法正常的解析中文，所以需要使用JavaScript函数对其 进行转码，所以在文件中使用了一个utf16to8()的函数对中文进行编码，之后生成的二维码就能正常使用了。 给出jsp文件中的全部内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;jQuery生成二维码&lt;/title&gt;&lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/jquery.qrcode.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;function utf16to8(str) &#123; var out, i, len, c; out = ""; len = str.length; for(i = 0; i &lt; len; i++) &#123; c = str.charCodeAt(i); if ((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F)) &#123; out += str.charAt(i); &#125; else if (c &gt; 0x07FF) &#123; out += String.fromCharCode(0xE0 | ((c &gt;&gt; 12) &amp; 0x0F)); out += String.fromCharCode(0x80 | ((c &gt;&gt; 6) &amp; 0x3F)); out += String.fromCharCode(0x80 | ((c &gt;&gt; 0) &amp; 0x3F)); &#125; else &#123; out += String.fromCharCode(0xC0 | ((c &gt;&gt; 6) &amp; 0x1F)); out += String.fromCharCode(0x80 | ((c &gt;&gt; 0) &amp; 0x3F)); &#125; &#125; return out; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div align="center"&gt; 生成的二维码如下&lt;br&gt;&lt;br&gt; &lt;div id="qrcode"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt;// jQuery('#qrcode').qrcode(utf16to8("但是人总得想办法,真的,要么忙着生存,要么赶着去死")); jQuery('#qrcode').qrcode(&#123;width: 200,height: 200,text: utf16to8("心怀希望是一件好事,也许是最好的事,心怀希望就永远有希望")&#125;); &lt;/script&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 生成的二维码如下： 小结网页的话一般没有解码的需求，所以老师也没有讲解jQuery解码的说明，所以网页项目只有生成二维码的过程。二维码生成与解析的博文至此告一个段落，由于博主的基础水平所限，所以偏向实用的内容，如何生成和解析二维码是我这次学习的目标，至于二维码的原理等内容，可以去慕课网Fcming老师的讲解，本文的所有代码是本人亲手所写并测试的，代码中难免有不足和错误的地方。还有本文偏向Java的技术栈，如果你希望使用PHP生成二维码可以去看看PHP QRCode生成二维码这篇课程。最后，再次感谢Fcming老师的讲解和慕课平台。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web应用</tag>
        <tag>JSP页面</tag>
        <tag>二维码</tag>
        <tag>jQRuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维码生成与解析：QRCode]]></title>
    <url>%2F%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E8%A7%A3%E6%9E%90%EF%BC%9AQRCode.html</url>
    <content type="text"><![CDATA[本文介绍使用QRCode生成和解析二维码 资源准备本次使用的是QRCode的Java构件生成和解析二维码，所以需要用到QRCode的JAR文件，在网盘以下中给出： 百度网盘：链接：https://pan.baidu.com/s/1vQZRPbRKzaQg3-XqsRc-Jw提取码：y8cq QRCode创建二维码使用QRCode生成二维码是使用的Java的绘图工具。代码的步骤和详细说明在代码注释中已经给出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.awt.Color;import java.awt.Graphics2D;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;import com.swetake.util.Qrcode;public class CreateQRCode &#123; public static void main(String[] args) throws IOException &#123; int version = 7; int picWidth = 67 + 12 * (version - 1); //生成二维码的宽度根据次公式确定 int picHeight =67 + 12 * (version - 1); //生成二维码的高度根据次公式确定 //1.定义一个Qrcode 对象并设置其纠错等级,编码模式(N-数字,A-英文字符,B-其他字符),版本1-40 Qrcode x = new Qrcode(); x.setQrcodeErrorCorrect('M'); x.setQrcodeEncodeMode('B'); x.setQrcodeVersion(version); //2.定义二维码内容 String qrData = "https://yangchaofu.cn"; //3.定义一个缓冲区图片 BufferedImage bufferedImage = new BufferedImage(picWidth,picHeight,BufferedImage.TYPE_INT_RGB); //4.定义一个图形对象(Graphic2D),并将缓冲区图片赋值给图形对象,并进行背景前景的设置和图像背景色的填涂(clearRect) Graphics2D gs = bufferedImage.createGraphics(); gs.setBackground(Color.WHITE); gs.setColor(Color.BLACK); gs.clearRect(0, 0, picWidth, picHeight); //5.将需要写入二维码的内容转为字节并设置编码为UTF-8 byte[] d = qrData.getBytes("UTF-8"); //6.进行二维码的绘制,使用一个偏移量pixoff int pixoff = 2; if(d.length &gt; 0 &amp;&amp; d.length &lt; 120)&#123; boolean[][] s = x.calQrcode(d); for (int i = 0; i &lt; s.length; i++) &#123; for (int j = 0; j &lt; s.length; j++) &#123; if(s[i][j])&#123; gs.fillRect(j*3 + pixoff, i*3 + pixoff, 3, 3); &#125; &#125; &#125; &#125; //7.gs释放屏幕资源,缓冲区图片刷新 gs.dispose(); bufferedImage.flush(); //8.将生成的图片输出 ImageIO.write(bufferedImage, "png", new File("C:/Users/yangc/Desktop/qr.png")); &#125;&#125; 创建结果： QRCode解析二维码QRCode解析二维码的效果并不如zxing，所以如果项目中使用，建议使用zxing。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;import jp.sourceforge.qrcode.QRCodeDecoder;import jp.sourceforge.qrcode.data.QRCodeImage;/** * 使用QRCode进行二维码解析 * @author yangc * */public class DeQRCode &#123; public static void main(String[] args) throws IOException &#123; //1.指定要解析的文件 File file = new File("C:/Users/yangc/Desktop/pic.png"); //2.将文件使用ImageIO读取到BufferedImage中 BufferedImage bufferedImage = ImageIO.read(file); //3.定义一个QRCodeDecode 对象 QRCodeDecoder codeDecode = new QRCodeDecoder();// //4.使用一个byte[]接受解析出来的内容 byte[] contentsByte = codeDecode.decode(new MyQRCodeImage(bufferedImage));// //5.对解析的内容进行String化并设置编码格式 String contentsStr = new String(contentsByte,"UTF-8"); System.out.println(contentsStr); //4-5步合在一起// String result = new String(codeDecode.decode(new MyQRCodeImage(bufferedImage)),"UTF-8");// // System.out.println(result); &#125;&#125;/** * 定义一个MyQRCodeImage类实现QRCode接口,用于二维码解析 * @author yangc * */class MyQRCodeImage implements QRCodeImage&#123; BufferedImage bufferedImage; public MyQRCodeImage(BufferedImage bufferedImage) &#123; this.bufferedImage = bufferedImage; &#125; @Override public int getHeight() &#123; return bufferedImage.getHeight(); &#125; @Override public int getPixel(int arg0, int arg1) &#123; return bufferedImage.getRGB(arg0, arg1); &#125; @Override public int getWidth() &#123; return bufferedImage.getWidth(); &#125; &#125; 解析结果：https://yangchaofu.cn 小结使用QRCode进行二维码的创建和解析说实话体验并不很好，有时候解析出来的一串内容，并没能将编码内容实际解析出来，所以建议使用zxing。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>二维码</tag>
        <tag>Java</tag>
        <tag>QRCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维码生成与解析：zxing]]></title>
    <url>%2F%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E8%A7%A3%E6%9E%90%EF%BC%9Azxing.html</url>
    <content type="text"><![CDATA[本文介绍使用开源库zxing生成和解析二维码。 使用zxing首先需要使用源码中的core和javase两个文件制作JAR文件，为了不偏离主题，将这部分放在最后一节讲解，本文直接提供制作好的JAR文件。 百度网盘：链接：https://pan.baidu.com/s/1vQZRPbRKzaQg3-XqsRc-Jw提取码：y8cq 使用zxing创建二维码将网盘中zxing文件夹中的zxing3.x.jar文件导入到项目中。以下的代码将在 C://Users/yangc/Desktop文件夹中创建一张二维码（pic.png）,二维码所携带的内容为：https://yangchaofu.cn。创建过程总共分为两个大步骤，第一个大步骤是创建前的准备工作，包含两个小步骤；第二个大步骤是创建步骤 ，包含三个小步骤，整体可以用以下列表结构表示： 制作前准备工作 定义图片信息和二维码内容 定义二维码的属性信息，包括纠错等级，编码格式，二维码边距 制作过程 使用MultiFormatRead的encode方法生成一个BitMatrix对象 指定输出路径 使用MatrixToImageWriter的writeToPath方法将BitMatrix对象写入文件 以下代码是对上述描述的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.File;import java.nio.file.Path;import java.util.HashMap;import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.client.j2se.MatrixToImageWriter;import com.google.zxing.common.BitMatrix;import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;/** * Java进行二维码制作-zxing * @author yangchaofu * @since JDK 1.8.192 */public class CreateQRCode &#123; public static void main(String[] args) &#123; //制作二维码的准备工作 //1.定义所要生成的二维码图片的长,宽,图片格式和所携带的信息 int picWidth = 300; int picHeight = 300; String picFormat = "png"; String picContents = "https://yangchaofu.cn"; //2.定义二维码的基本属性配置,使用散列表存储,最基本的设置包括二维码的编码格式,纠错等级和图片的边距 HashMap hints = new HashMap(); hints.put(EncodeHintType.CHARACTER_SET, "utf-8"); //设置编码格式,utf-8可设置中文 hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M); //设置纠错等级 hints.put(EncodeHintType.MARGIN, 1); //设置生成二维码边距 //生成二维码的步骤 try &#123; //1.定义一个为BitMatrix 对象,使用MultiFormatWriter 对象的encode方法设置二维码的内容,编码格式BarcodeFormat,宽,高,设置信息hints BitMatrix bitMatrix = new MultiFormatWriter().encode(picContents, BarcodeFormat.QR_CODE, picWidth, picHeight,hints); //2.定义一个Path对象用于确定文件的输出位置 Path file = new File("C:/Users/yangc/Desktop/pic.png").toPath(); //3.使用MatrixToImageWriter 对象的writeToPath方法,将二维码图片输出到指定的位置,设置格式为我们准备阶段的格式 MatrixToImageWriter.writeToPath(bitMatrix, picFormat, file); System.out.println("生成二维码成功!"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 代码执行结果： 使用zxing解析二维码解析二维码包括三个大步骤，用以下结构描述 解析前准备 准备一个文件对象，指向需要解析的二维码图片 使用ImageIO读取该图片对象为缓冲区图片BufferedImage 将BufferedImage转换为一个二进制位图对象 定义一个散列表存取二维码的编码格式 解析过程步骤 定义一个MultiFormatReader 对象,用于解码 定义一个Result 对象用来获取解析的结果,这里的参数使用到前面准备的两个重要的数据,被转换为BinaryBitmap的图片对象,和定义解码配置的散列表hints 解析结果的展示（可以直接toString得到解析结果，也可是使用getText获取解析文本，使用getBarcodeFromat获取二维码格式） 以下是上述过程的代码表述： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.awt.image.BufferedImage;import java.io.File;import java.util.HashMap;import javax.imageio.ImageIO;import com.google.zxing.BinaryBitmap;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatReader;import com.google.zxing.Result;import com.google.zxing.client.j2se.BufferedImageLuminanceSource;import com.google.zxing.common.HybridBinarizer;public class DeQRCode &#123; public static void main(String[] args) &#123; try &#123; //解析前准备步骤 //1.定义一个File 对象,指向我们要解码的二维码位置 File file = new File("C:/Users/yangc/Desktop/qr.png"); //2.定义一个BufferedImage 对象,并使用ImageIO类的read方法读取我们的File对象(一张图片) BufferedImage image = ImageIO.read(file); //3.定义一个BinaryBitmap 对象,使用多重嵌套 实例化将我们的image转换成一个BinaryBitmap对象,多重嵌套声明包括HybridBinarizer-&gt;(参数)BufferedImageLuminanceSource-&gt;(参数)BufferedImage[image] BinaryBitmap binaryBitmap = new BinaryBitmap(new HybridBinarizer(new BufferedImageLuminanceSource(image))); //4.定义一个散列表,指定编码的一对键值 HashMap hints = new HashMap(); hints.put(EncodeHintType.CHARACTER_SET, "utf-8"); // 设置编码格式,utf-8可设置中文 //解析过程步骤 //1.定义一个MultiFormatReader 对象,用于解码 MultiFormatReader formatRead = new MultiFormatReader(); //2.定义一个Result 对象用来获取解析的结果,这里的参数使用到前面准备的两个重要的数据,被转换为BinaryBitmap的图片对象,和定义解码配置的散列表hints Result result = formatRead.decode(binaryBitmap, hints); //解析结果展示 //rusult的toString可以展示解析结果 System.out.println("解析结果:"+result.toString()); //result文本信息可以展示二维码所携带的文本内容 System.out.println("二维码文本内容:"+result.getText()); //解码的格式可以获取二维码的编码标准和格式 System.out.println("二维码格式:"+result.getBarcodeFormat()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 以上代码的解析结果：解析结果：https://yangchaofu.cn二维码文本内容：https://yangchaofu.cn二维码格式：QR_CODE 使用zxing源码制作JARgithub上有很多非常优秀的开源项目，这次使用的zxing就是其中之一，如何复用这些代码呢，对于Java来说，jar文件是不陌生的。我在这次实践中第一次体会到了使用源码制作jar文件的过程，记录在此处。 新建一个Jave项目； 将下载的zxing文件夹中的core和javase两个文件中下的com文件复制到项目的src中，复制中会有文件存在的提示，选择是就可以； 由于项目不是完整的项目，项目中会有很多的错误提示，这个不用管，因为我们使用IDE的时候，IDE会帮助我们管理文件的，所以直接选择导出JAR文件，之后我们就可以得到一个最新的zxing的可复用构件。 小结以上代码实现了使用zxing创建和解析二维码，经测试所生成的二维码识别率和准确性都是满足要求的，解析代码的识别率也很高。zxing是一个很好的解决方案。感谢慕课网Fcming老师的讲解和慕课网这个平台，十分感谢！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>二维码 - zxing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习总结]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[本来以为一天完成的Git学习任务，用了三天勉强完成，真是拖延病入膏肓，不过还好没有拖到猴年马月，也算完成了一个小任务，那就上来好好的总结一番。 Git是什么我想有好多人听过但是不清楚，不过可能是我比较Low，直到现在才基本算入门吧，但是我相信还有好多不知道的，比如不是计算机专业的，好了废话不多说，我们一个问题一个问题来说一下！！ 什么是Git？先引用出官方的说法： Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows. 翻译一下就是： Git是一个免费开源的分布式版本控制系统，其设计的目的是快速、高效的处理从小到大的各种项目。 Git很容易学习，占用空间小，执行快如闪电。它比其它版本控制台工具，比如：SbuVersion，CVS，Perforce和ClearCase具有更优的特性，比如简易的本地分支，便利的暂存区域和多工作流。 大概意思还是表达出来了，就是它是什么，它和同类产品相比，特性是什么。首先它是一个版本控制工具，这个概念学过软件工程的同学都听过，不过没实践过还是很难理解，我会以写大作业的例子作类比。特性就是快，小，强，怎么强还给出了具体的说明，分支，暂存和多工作流等，侧面的表达了其它同样类型工具的各种不足，比如占用空间大，速度慢，分支复杂切换分支慢，暂存不方便等等。 顺便说一句，我最初了解Git的时候是因为GitHub，编程的人应该都知道GitHub，上面有很多的开源软件项目，毕竟我们是面向API编程，那它和Git之间有什么关系呢？后面会简单说一下，除了国外的GitHub其实还有国内的Gitee（码云），这名字起的好。 什么是版本控制？我以word为例举个例子，比如你在写毕业设计，你首先先建了一个word文档，叫作XXX毕业设计，然后我们在里面一顿写，终于完成了初稿。 然后交给我们的导师去检查，但是导师看了十分不满意，这写的什么玩意，就这还想毕业……然后你需要对你的的毕业设计进行修改，你又怕改了之后以前的内容找不回来了，所以你将你的毕业设计备份了一份，把原来的版本叫做XXX毕业设计-初稿，新版本叫XXX毕业设计-0.01 然后你在0.01版里面一顿乱改，之后再交到导师哪里？导师还是不满意，还不如第一版。。你又在0.01版新建一个备份叫0.02，又在里面一顿胡乱增删改，你的文件夹变成了这样： 然后你一直进行这样的操作，突然你的导师和你说，我觉得你有一次给我看的有一个地方我觉的挺好的，你把它重新写上，你们说的你都记得，但是你就是不知道在那个版本了，这样又是一顿找，总之各种工作效率低。 以这样一个简单的例子类比了版本控制这个过程，但是实际的工程项目比这要复杂的多，一个版本和另一个版本之间的修改可能达到上百处，工程文件的复杂程度是不可想象的，此时版本控制就变得很必要。 那Git怎么学？这里就需要祭出我的Git恩师廖雪峰老师了，他的Git教程我觉得最有条理，入门首选： 廖雪峰老师的Git教程 其次就是官方的教程了，多去逛逛必定好处多多： Git官方中文文档 学了用在什么地方？ 首先Git的起源就是用于软件的版本控制，所以第一用途就是软件版本控制； 对于非开发人员来说，Git可以用于Office文档的版本控制，我亲测，Git是可以控制Office2016所产生的文档的，有一个需要注意的点是Git在分支切换的时候要关闭Office软件以解除文档的占用。 GitHub和Git什么关系？如果已经认真学习了廖雪峰老师的教程，那我想这个问题已经明了，我这里只是用自己的话说一遍，Git最大的特点就是是它是分布式的版本控制系统，所以它的工作都是在本地的，如果有多人一起工作，那么使用GitHub这样的Git服务器只是充当一个交换的作用，每个合法的用户都可以向GitHub中push自己的修改，它其实还提供了一个源代码分享平台，可以这样说Git和GitHub极大的促进了代码的流通，它使全球的开发者连结在了一起。而现在微软收购了GitHub，这家全球软件巨头在开源的动作有目共睹，我相信它能很好的经营GitHub。 总结Git能做很多事情，电子数据最大的优势就是其快速的更迭，这是很有利的，数据的易于产生和交换使的我们的生活在数字的影响下磅礴发展，互联网将人们与世界相连，这是人类文明的创举。而正如大家所知，万维网的发明人Timothy John Berners-Lee，并没有从他的贡献中获取利益，Linus Towards不仅发明了Linux而且发明了Git，这些人都是值得我们去尊敬和铭记的，代码是现代的魔法，能接触这个行业是我的幸运，希望自己能立足当下，以成为像他们一样的代码大师而努力。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构：快速排序法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B3%95.html</url>
    <content type="text"><![CDATA[快速排序法是排序算法中综合性能最好的一种，Java语言和C++语言都自带了快速排序算法的库函数，足以见得其效率。 本次算法的实现思路来自于博客，网上的快速排序实现方式基本有两种形式，其中之一就是本文参考的这一种，还有一种是百度百科里面的哪一种，具体那种更优我觉得差异不大，其核心思路都是一样的。 本文使用的快速排序算法的思路：从待排序数组中找一个数作为标杆(对于这个数怎么选择众说纷纭,我为了让算法简单选得是每次待排序数组的第一个元素)，每一趟快速排序将比标杆大的数放在它的右边，比它小的数放在标杆的左边，实现一轮快速排序。然后通过递归调用，将标杆左边的数组又作为一个参数,直到需要排序的数组只有一个数为止。 实例：有待排序数组array，其长度为arr_len，其中的数据元素有 113,22,58,3,1,2，1 共计有七个个元素，我们以第一个元素13为标杆，进行第一轮快速排序，得到如下结果： 11 1 2 3 13 58 22 可以看到，我们将比13大的元素放在了该元素的右边，比13小的元素放在了该元素的左边，但是数组还不是有序的。但程序已经基本有序，我们以13为分割，对13左边和右边的数组再次实现上述过程。 13左边已经有序：11，1，2，3 13右边：12待排序数组：58，22排序完成：22，58 由于我们传递的是数组的地址（指针方式）和需要排序的数组的下标，比如13右边的数组传递的就是数组array，start：6，finish：7 程序的大概思路如上所述，下面给出代码实现，本次采用C语言实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* 本程序实现对一组整形数的快速排序实现 2018年6月20日 16:38:43 yangchaofu*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;/*两种数组传递的函数原型*/void quicksort(int array[],int left,int right);// void quicksort(int *array,int array_length);int main(void)&#123; int array[]=&#123;13,22,58,3,1,2,1&#125;; int arr_len = sizeof array / sizeof array[0]; /*输出数组*/ printf("Array's length: %d\n",arr_len); for(int i = 0; i &lt; arr_len; i++) &#123; printf("%d ",array[i]); &#125; putchar('\n'); quicksort(array,0,arr_len-1); /*排序后的输出结果*/ for(int i = 0; i &lt; arr_len; i++) &#123; printf("%d ",array[i]); &#125; putchar('\n'); system("pause"); return 0;&#125;/*quicksort函数对给定的数组进行快速排序 */void quicksort(int array[],int left,int right)&#123; /*递归结束条件,很重要的一个点*/ if(left &gt;= right) return; int l = left, r = right; /*每次排序一需要排序的数组的第一个数作为标杆,将比它大的数放在它的右边,比它小的数放在它的左边(倒序与之相反)*/ int temp = array[left]; while(l != r) &#123; /*从右往左找一个比标杆temp小的数,l &lt; r 避免出现l比r大程序还在循环的异常,程序在l==r时需要跳出循环*/ while(array[r] &gt;= temp &amp;&amp; l &lt; r) r--; /*从左往右找一个比标杆temp大的数*/ while(array[l] &lt;= temp &amp;&amp; l &lt; r) l++; /*寻找完毕,执行至此,找个一个比标杆小的值array[r]和一个比标杆大的值array[l]*/ if(l &lt; r) &#123; /*如果目前找到的比标杆小的值array[r]在比标杆大的值array[l]的右边,即:两数下标 l &lt; r ,则交换两个数*/ int t; t = array[l]; array[l] = array[r]; array[r] = t; &#125; &#125; /*上面的循环实现快速排序中的比标杆大的数和比标杆小的数的交换,快速排序的交换逻辑可以有多种实现方式 除以上实现方式外,还有标杆在比较中,随着程序的执行进行位置的更换. 本程序实现其中一种逻辑,到目前为止,标杆依旧在数组的最左边,需要将其和l=r这个位置的数进行交换. */ int temporary = array[r]; array[r] = temp; array[left] = temporary; /*至此,一趟快速排序结束,使用递归重复上述过程 此处递归的写法有两种,使用的r下标实际上与l下标的值是相等的,使用那一个都可以. */ for(int i = 0; i &lt; 7; i++) &#123; printf("%d ",array[i]); &#125; putchar('\n'); quicksort(array,left,r-1); quicksort(array,r+1,right);&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java：基本概念]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
    <content type="text"><![CDATA[Java的复习工作已经在进行，是为了后面的Web开发和安卓学习打下基础。Java语言是一门强大的语言，Java的出现是在C++语言之后，对C++语言的各种缺陷（被认为让人难以理解或者容易产生逻辑错误的地方）进行的各种改进而产生的一门面向对象的语言，它可以说是对C++语言的一次优秀的革命，使得C++这门强大的，扩展了强大的C语言，具有面向对象、面向过程两种设计模式的语言，变成了纯面向对象的语言，取消了指针（内存地址操作）这个比较难以弄懂的语言特征，并且带有诸如异常处理等高级特征，一经问世，备受追捧，久经沙场之后，走到了程序语言的顶峰，其强大特性直接或间接催生了C#这门与之十分相似的强大程序语言。 Java中几个关键字的作用需要去了解一下,以前没有用过 删除线表示原来不知道，后来看了对应的资料，有所了解 对象相关 implements 用于实现接口，接口更像是一种约定，一个类可以实现多个接口 instanceof 用于判断一个引用的类对象 方法变量和类修饰符 abstract 用于修饰抽象类，抽象类是具有空方法的类，抽象类不能被实例化，抽象类的继承同普通类，抽象类和接口的区别后面会提到 transient volatile strcitfp Java中变量作用域 一个变量位于类内部,成为字段或者属性,成员变量,Field 声明在方法内的变量,叫做局部变量,不能在类中使用这个变量 当一个变量被 final 修饰时,该变量只有一侧赋值机会,可用作常量的定义和设置不被继承 Java中的运算 同种变量类型运行(包括整形和浮点型),运算结果取类型较大的 逻辑运算分为长短两种,长逻辑需要两边都运算,短逻辑只需一边运算,逻辑或需要两边运算 位运算有位或和位与两种操作 位运算左移相当于乘2,右移相当于除2 有符号的数据左右移位,移位之后还是对应的符号;不带符号的数据左右移位,正负改变 Java中数组的使用 Array.toString方法用来打印十分方便 System.arraycopy(src, srcPos, dest, destPos, lengtObject)的用法,@parm src: 源数组@parm srcPos: 从源数组复制数据的起始位置@parm dest: 目标数组@parm destPos: 复制到目标数组的起始位置@parm lengtObject: 复制的长度的用法 Arrays的各种用法 coypOfRang — 数组复制 toString — 转换为字符串 sort —排序 binarySearch — 搜索 equals — 判断是否相等 fill — 填充数组 Java中Arrays. sort使用了两种排序方法，快速排序和优化的合并排序。快速排序主要是对哪些基本类型数据（int,short,long等）排序。而合并排序用于对对象类型进行排序。原因：使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一直。另外一个原因是由于合并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，移动是简单的，只是引用的转换，但是比较相对更加耗时。合并排序的时间复杂度是n*logn, 快速排序的平均时间复杂度也是n*logn，但是合并排序的需要额外的n个引用的空间。 类和对象 引用的概念，如果一个变量的类型是 类类型，而非基本类型，那么该变量又叫做引用。例:new XXX();就是一个引用,它不是基本类型,而是 类类型. Object Object = new Object();Object这个变量是Object类型，又叫做引用=的意思指的Object这个引用代表右侧创建的对象“代表” 在面向对象里，又叫做“指向”. 123456789public class Object &#123; String objectName; public static void main(String[] args) &#123; new Object(); Object object = new Object(); &#125;&#125; 一个引用同时时间可以指向多个引用 123456Object Object1 = new Object();Object object2 = object1; //Object2指向Object1所指向的对象Object object3 = object1;Object object4 = object1;Object object5 = object4;//所有的object1,2,3,4,5同时指向一个Object对象 方法重载的概念,重载就是同样名字的方法可以写多个,每个方法有不同的参数列表,在使用是,JVM根据传人的参数数量自动识别并调用对应的方法. 123public returnType mehod();public returnType mehod(type a);public returnType mehod(type x,type y); 构造方法的概念每一个类都有一个构造方法,构造方法可以重载,不写时默认有一个无参构造方法,构造方法名与类名相同,构造方法无返回值,可见性为public,当使用new关键字引用一个对象时,默认调用该对象的构造方法. 使用static修饰的的方法或者属性,叫做类方法和类属性,一个被声明静态的属性和方法,被所有对象共享,建议使用类来获取该属性和方法,一突出其类属性和类方法的概念,与之对应的叫做对象属性和对象方法. Java中使用文档注释，可以才新建项目的时候勾选添加注释，也可以是使用快捷键Alt+Shift+J键进行添加,注释的基本写法如下,使用官方提供的注释标识,常用的如下表: 标记 标识 用于 @author 作者 类注释 @version 当前软件版本 类注释 @since JDK版本 类注释 @see 链接到其他Javadoc 类注释 {@link} 统@see,使用更加自由,可以在前面添加描述信息 类注释 @param 参数详解,后面跟参数名 方法注释 @return 返回值详解 方法注释 单例模式具有两种写法，使用单例模式在JVM中只能实例化一个对象，在一些特定场景使用单例模式是必要的，比如在GUI中使用的的Frame，在一些设计场景中的只有一个的对象。单例模式有两种实现方式，下面的代码分别对这两只模式进行解读。1234567891011121314151617181920212223242526//饿汉式单例模式public class Object&#123; //私有化构造方法，使对象无法示例化新的对象 private Object1(); //实例化一个该类的对象 private Object instance = new Object()； //获取该类的单例 public static Object getInstance()&#123; return instance; &#125;&#125;//懒汉式public class Object&#123;s //私有化构造方法 private Object(); //定义一个本类型的属性 private Object instance; //获取该类的单例 public static Object getInstance()&#123; if(null == instance)&#123; instace = new Object(); &#125; return instance; &#125;&#125; 两种模式使用时的选择，如果在构造方法中有大量的需要初始化的东西，代码量大的情况下，使用饿汉式可以减少时间，提高效率；懒汉式具有线程安全的考虑。 枚举类型。枚举也是一种类，是对一些常量的定义，最简单的例子，一个星期五天，一年四个季节使用枚举可以表述的更清晰（相比于使用1、2、3、4）这样的样例还有很多，实际使用的时候需要多作考虑。123public enum Season&#123; SPRING,SUMMER,AUTUMN,WINTER&#125; 接口与继承 接口的意义，接口相当于一种约定，实现某一个接口就必须要实现该接口中的方法。Java中一个子类只能继承一个父类，但是可以实现多个接口 12345678910111213public interface IntFace&#123; //继承该接口必须实现method方法 pulic void method()&#123;&#125;;&#125;//使用implements关键字实现接口，实现接口中的method方法public class Obejcet implements IntFace&#123; //重载接口的方法 @Override public void method()&#123; .... &#125;&#125; 引用类型和对象的概念，如何一个非基本数据类型定义出来的变量都称为引用，而使用new 关键字调用构造方法生成的，就叫做对象类型。引用类型转换的指向可以由子类向父类转换。这样是一定成功的，比如说： 12345678//Java中所有的类都是Object的子类，所以以一个这样的例子来介绍引用类型public class A extends Obejcet&#123; ...&#125;//理解方法：把右边的当作左边的用，看行不行得通//该例中，把对象类型A当作父类性Object是完全说的通的，所以可行Obejcet obj = new A(); 如何判断一个引用类型的的对象，使用instanceof关键字可以确定一个引用指向的对象类型 12Object obj = new Object1();System.out.print(obj instanceof Object); 重写和覆盖与重写类似，方法的重写是子类覆盖父类的对象方法 ；隐藏，就是子类覆盖父类的类方法。 super关键字可以在子类中调用父类的有参构造方法（子类默认调用父类的无参构造方法而且是一定会调用），使用super关键字可以调用父类的属性和方法。 Object是所有子类的父类，Object有如下方法：Object具有的方法 方法 作用 toString 对象的字符串表达 finalize 垃圾回收时调用该方法 equals 用于判断两个对象的内容是否相等 hashCode wait、notify，notifyAll 线程同步方法 getClass 返回一个对象的类对象 final关键字修饰类，方法，基本类型变量和引用类型时有不同的含义 修饰 意义 类 该类不能被继承 方法 该方法不能被重写 基本类型变量 该基本类型变量只能被赋值一次 引用 该引用只有一次指向对象的机会 抽象类 *来自how2.cn抽象类内容在类中声明一个方法，这个方法没有实现体，是一个“空”方法，这样的方法就叫抽象方法，使用修饰符“abstract” 当一个类有抽象方法的时候，该类必须被声明为抽象类。 继承抽象类的子类必须提供不一样的抽象方法； 抽象类不能被实例化； 抽象类和接口的区别 抽象类 接口 子类只能继承一个抽象类，不能继承多个，抽象类的继承同普通类 子类可以实现多个接口 抽象类可以被定义 public、protected、package、private，静态和非静态属性 接口只能被定义为public、静态和final的，即使书写的时候没有用到public static final。。也会自动添加上去 接口当成一个协议，实现了这个接口（协议）的类就应该实现接口中的方法（协议内的条例），接口是约束调用本接口的类而不是给类提供能力。抽象类则是让继承此类的子类一定要实现某个方法。例如取快递是一个抽象类，签收是抽象方法，那么一定要实现签收方法才能完成取快递。 本部分为Java的基础内容，记录并常回顾。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建博客|Hexo+Github+NexT]]></title>
    <url>%2FHexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[个人博客是继Email、BBS、IM之后的第四种网络信息传播方式，是一个区别于当前流行的（QQ空间，微信朋友圈，微信公众号，微博，贴吧，知乎，简书，论坛）信息分享平台，他有强烈的个人标识和非常高的个性化。说了这么多，我想说的是我搭建了一个博客，我有话要说，:muscle: 博客诞生同其他几个一样，在互联网兴起之后，人们对信息分享和流通的需求逐渐加大，而这个需求在当时还不能由上述所说的各种产品满足，所以博客成为了当时的一种信息共享方式；在当时写博客的人应该多是互联网从事者，因为当时互联网使用率很低，也没有WordPress，Joomla，Hexo这样简单好用（相对而言）的建站工具，建站难度很高，个人建站的话，必须精通网络知识而且能够进行Web开发。即使博客能顺利建立，以后面临的另一个问题就是内容流通性差，互联网太广太大了，光靠搜索引擎不能使更多的信息流通起来，所以有很多的商业公司瞄准了这个市场，于是就诞生了以上的那些产品，它们各有特色，互为补充，几乎每一个国内的互联网使用者都有用过其中一二。 前言作为一个CS专业的大学生，书写博客是我们自身的需要，它不像在纸上书写，计算机显示技术能将我们想要表达的很多内容，清晰，明确的表现出来，举几个简单的例子：代码高亮，动态图演示等，都是书本不具有的，所以各种技术论坛，如CSDN、博客园、开源中国、Stack Overflow就应运而生，从一个方面来说，个人博客存在的意义已经不大了，但从另一个方面来说，个人博客与GitHub是一张好的名片。 Talk is cheap. Show me the code.—Linus Torvalds 正文博客建成就是你能看到的这个样子，功能基本齐全，评论功能由于体验十分糟糕所以弃用了 ，其他的一些功能觉得不必要就没有弄，如果你有什么问题和反馈可以从侧边栏使用邮件或者通过Github给我留言。那些深度定制的博客十分惊艳，做之前可以先看看可以达到什么样的高度。 Hexo博客深度优化样例 在我建站的过程中，参考了大量他们的经验分享，这里我也将我的建站经历写出来，以供参考。 建站的首先需要安装一些软件，安装过程为了准确，我直接引用Hexo文档的内容，建议直接参考Hexo的文档，文档写的很漂亮。 以下关于Hexo配置的内容多来自Hexo官方网站 我们正式开始 什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装 安装 Hexo 只需几分钟时间，若您在安装过程中遇到问题或无法找到解决方式，请提交问题，我会尽力解决您的问题。 安装前提 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 $ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 Mac 用户 您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。 安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts ：brew install git;或下载安装程序安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Windows 用户 由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。 安装 Node.js 安装 Node.js 的最佳方式是使用 nvm。 cURL: $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget: $ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 $ nvm install stable或者您也可以下载 安装程序 来安装。 Windows 用户 对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装 Hexo 所有必备的应用程序安装完成后，即可使用npm安装 Hexo。 $ npm install -g hexo-cli 到此为之你的Hexo博客所需的前提就已经准备完毕了，下一步需要生成一个Hexo文件并进行配置，一下内容同样来自Hexo的文档。 建站 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 $ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml是网站的配置信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "" &#125;, "dependencies": &#123; "hexo": "^3.0.0", "hexo-generator-archive": "^0.1.0", "hexo-generator-category": "^0.1.0", "hexo-generator-index": "^0.1.0", "hexo-generator-tag": "^0.1.0", "hexo-renderer-ejs": "^0.1.0", "hexo-renderer-stylus": "^0.2.0", "hexo-renderer-marked": "^0.2.4", "hexo-server": "^0.1.2" &#125;&#125; scaffolds 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source 资源文件夹是存放用户资源的地方。除_posts文件夹之外，开头命名为 _(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public文件夹，而其他文件会被拷贝过去。 themes 主题文件夹。Hexo 会根据主题来生成静态页面。后面我们会为我们的博客安装NexT主题。 又一里程碑，这一个部分我们需要对我们的博客进行配置，新手就按照官方文档配置就可以，先看到结果，后续你可以进行复杂的配置和高度的个性化定制，在博客上花时间越多，你就越理解Hexo这个框架的逻辑。 配置 写在前面的话，网站的配置对格式的要求非常严格，特别是缩进的要求，一般都是冒号之后一个空格，然后参数值，这个问题需要特别主要，最好使用Atom之类的编辑器来编辑，因为它会根据不同的缩进有不同的颜色颜色 您可以在 _config.yml 中修改大部份的配置。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 zh-Hans timezone 网站时区。Hexo 默认使用您电脑的时区，大陆使用的是 Asia/Shanghai 本站的网站配置 12345678# Sitetitle: GALAXYsubtitle:description: 永远年轻，永远热泪盈眶keywords:author: 沼泽星空language: zh-Hanstimezone: Asia/Shanghai 网址 参数 描述 默认值 url 网址，用于连接你部署的域名 Root 网站根目录 permalink 文章的永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 本站的网址配置 123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://https://yangchaofu.cn/root: /permalink: :title.htmlpermalink_defaults: 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 本站的目录配置 123456789# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: 提示 如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case(大写) false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 本站的文章配置 123456789101112131415# Writingnew_post_name: :title-:year-:month-:day.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: 相对地址 默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 本站的分类&amp;标签配置 1234# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map: 日期 / 时间格式 Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 本站的日期/时间配置 123456# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 本站的分页配置 1234# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 本站的扩展配置 123456789101112# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git //这里需要注意，请严格按照以下格式来书写，避免麻烦，如果不想暴漏密码可以找网上的其他教程 repo: https://yourname:yourpassword@github.com/yourname/yourname.github.io.git branch: master 以上我基本就是把官方文档抄了一遍，然后对应给出我的网站的配置，初看官方文档如同课本一样，会觉得晦涩难懂，但配合着我的配置和我的博客的外观，你应该能够多数看明白，所以，你即使看不懂也要大概的过一遍，自己建博客的时候就不会两眼一发黑。 以上的配置有一个地方初次使用时需要注意，即主题，NexT主题是需要下载安装的，未下载了配置可能会出错，主题安装在后续给出说明。 又完成了一个重要步骤，下一过程你就可以创建你的第一篇博文并部署测试了 几个重要的命令写在前面，使用博客过程中你会大量使用的这几条命令，先混个眼熟，有些命令是缩写，括号内部给出全程 命令 描述 hexo init 对一个文件夹进行初始化，进行Hexo的本地配置 hexo clean 对public中生成的文件进行删除 hexo g （generate） 根据sources文件中的博文和站点配置文件以及主题配置文件生成文件放入public hexo d（deploy） 将public中的文件部署到_config.yml中deploy配置的地方 hexo s（server） 对博客进行本机测试，理解B/S结构程序的同学应该都明白，不明白不要紧 _生成和部署命令可以混合使用，例如：hexo g -d 生成一篇本地新博文123hexo new "tiele"//事例hexo new 我的第一篇博文 该命令会生成一篇位于source/_posts/的博文，生成的博文会根据_config.yml的new_post_name:来生成博文名；还会根据 scaffolds 模版文件中的post中的内容对新建的博文进行填充一部分内容，你可以自己定义内部的内容。 比如本博客的博文名生成方式如下： 1new_post_name: :title-:year-:month-:day.md # File name of new posts 根据以上事例就会得到这样一个博文名字： 我的第一篇博文-2018年-5月-10日 然后根据scaffolds中的post文件家生成的填充内容如下： 12345678910---title: 我的第一篇博文-2018年-5月-10日comments: true //开启评论功能，需要有外部的文件支持，由于体验不好所以，本博客暂时没有使用评论系统date: 2018-05-10 17:24:13 //创建时间tags: //标签 - Hexo - NexTcategories: //分类，分类和标签在官方文档中有很好的说明 - 随笔--- 后面你就可以写你的博文内容了，Hexo默认使用的是Markdown来作为内容书写格式，你需要简单的学习一下Markdown语法，但是不是非常困难，可以依托互联网快速学习，其中有很多深入的东西，比如画图和数学公式可以稍微放一下，主要对标题、序列、代码、图片、超链接、表格、加粗、斜体等了解即可，当然，这么优雅的语言深入学习是必须的，还有，书写的时候可以配合html来做到更好的效果，官方也为我们提供了一些特别的标签，可以参考官方文档，使用一些插件，我们可以在我们的博文中引入图片和视频这些比较高大上的东西，这个内容在后续会单独说说道。注意一点，博文会有阅读全部和部分的摘要两个方面，怎么分割呢，使用 &lt;!-- more --&gt;来实现 第一篇博文写好了之后，就是使用控制台或者Git Bash进行发布的时候了，比如说我们使用Windows，我们用控制台进入到我们博客站点所在的文件夹下，然后进行hexo g命令生成文件，然后使用hexo s，在浏览器中输入localhost:4000进入预览，然后进行更改，觉得没有问题之后使用hexo d进行部署到GitHub的仓库中，在浏览器中输入yourgithubname.github.io即可进行访问。你的第一篇博文就诞生了，但是官方主题相对第三方而言差了一点，所以我们复习要对它进行主题的更改，这里就需要安装NexT这个优雅的主题了，这里希望大家照着NexT的官方文档一步一步来，弄不清楚多看几遍，网络上的好多内容参差不齐，官方文档是相对而言最好的参考，质量有保证。NexT官方文档 好，到这一步假设你已经安装好了NexT，并进行了一些配置，但是你肯定忘了一些，或者根本无从下手的，那么再从这几个地方看看，你配置了吗？ 主题设置 菜单界面 侧边栏 头像设置 统计功能 不算子统计 本地搜索 菜单页面的配置 代码高亮 外部链接 根据NexT官方文档对该主题进行配置之后，你的博客将具有侧边栏的头像，侧边栏的链接,同时你的菜单将拥有关于，标签，归档，本地搜索这些菜单选项，已经十分强大了，基本上我们的博客就建立完毕了，如果你没有更多的要求，那么，已经可以收手了，博客主要还是要有内容的保证 深度的定制 对于希望博客更加好用好看的同学，可以参考以下两个内容，第一个功能非常的繁多，可以从中选择自己喜欢的进行配置，而第二个就需要特别隆重的推荐一下了，我觉得这是Hexo建站的巅峰，我见过做过最好的一个，而且毫不吝啬的给出来深度定制的教程，好多内容可以从中参考，希望自己的博客也能如此漂亮的同学可以通过他给出的文档得到满足。 Hexo+NexT的众多配置选项 Hexo博客深度优化其中第二个强烈建议大家去预览看看，做的很漂亮，而且很工整，对大家后面书写博客和对博客个性化有巨大的帮助。 还有一个问题是文件的存储问题，一般网络上都是使用网络存储空间然后引用的方法，这里推荐大家一个存储的地方，目前是免费的。 爱信息图床 参考牛顿曾经说过：我之所以能看的远，是因为我站在了巨人的肩膀上；IT界也有一种说法叫不到万不得已，不自己“造轮子”，其实他们是一样的概念，知识是人类巨大的宝库，参考别人的经验是一个人一生学习的技能。 Hexo中文文档 NexT官方文档 最详细的Hexo Next主题配置教程 从零建站 Hexo+NexT的众多配置选项 Hexo博客深度优化 玩转Hexo博客之Next Hexo添加字数统计、阅读时长 hexo搭建的博客如何给文章分类（NEXT主题） next主题之第三方评论系统 Hexo Docs基本用法 建站启蒙 部分内容参考 Next主题(Hexo) hexo搭建个人博客–NexT主题优化 Hexo博客中插入音乐 Hexo-next百度和谷歌搜索优化]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
